schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type AVGSPotentialAnalysisLicenseDefinitionData implements LicenseDefinitionData {
  kind: LicenseDefinitionDataKind!
  name: String!
}

input AVGSPotentialAnalysisLicenseDefinitionDataInput {
  name: String!
}

type AVGSPotentialAnalysis_AcceptedForUser implements AVGSPotentialAnalysis_ForUser {
  client: User
  kind: AVGSPotentialAnalysis_ForUserKind!
}

type AVGSPotentialAnalysis_Dimension {
  dimensionId: Int!
  dimensionText: String!
  questions: [PotentialAnalysisQuestion!]!
}

interface AVGSPotentialAnalysis_ForUser {
  kind: AVGSPotentialAnalysis_ForUserKind!
}

enum AVGSPotentialAnalysis_ForUserKind {
  AcceptedForUser
  InvitedForUser
}

type AVGSPotentialAnalysis_Info {
  """The ID of an object"""
  id: ID!
  numAvailableLicenses: Int!
}

type AVGSPotentialAnalysis_InvitedForUser implements AVGSPotentialAnalysis_ForUser {
  email: String!
  kind: AVGSPotentialAnalysis_ForUserKind!
}

type AVGSPotentialAnalysis_LearnPotentialAnalysis {
  """The ID of an object"""
  id: ID!
  isFinished: Boolean!
  modules: [AVGSPotentialAnalysis_Module!]!
}

type AVGSPotentialAnalysis_Module {
  dimensions: [AVGSPotentialAnalysis_Dimension!]!
  moduleId: Int!
  moduleText: String!
}

type AVGSPotentialAnalysis_PotentialAnalysis implements Node {
  base64EncodedReport: String
  client: AVGSPotentialAnalysis_ForUser!
  coach: User
  coachAccount: Account
  createdAt: ZonedDateTIme!
  """The ID of an object"""
  id: ID!
  isFinished: Boolean!
  linkToPotentialAnalysisOrInvitation: String!
  modules: [AVGSPotentialAnalysis_Module!]!
  replacementCoach: User
}

type AcademiesAccountExtension implements AccountExtension {
  baseData: baseData!
  kind: AccountExtensionKind!
  licenseModelKind: Kind
  licenses(after: String, before: String, first: Int, last: Int): LicenseConnection!
  users(after: String, before: String, first: Int, last: Int): UserInAccountConnection!
}

type AcademiesChildTag implements AcademiesTag {
  canBeDeleted: Boolean!
  children(after: String, before: String, first: Int, last: Int): AcademiesChildTagsConnection!
  coordinates: AcademiesTagCoordinates!
  data: AcademiesTagData!
  id: ID!
  kind: AcademiesTagKind!
  subId: ID!
}

"""A connection to a list of items."""
type AcademiesChildTagsConnection {
  """A list of edges."""
  edges: [AcademiesChildTagsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type AcademiesChildTagsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: AcademiesChildTag!
}

type AcademiesProductExtension implements ProductExtension {
  atGrossPrice: BigDecimal!
  chGrossPrice: BigDecimal!
  costUnit: String
  deGrossPrice: BigDecimal!
  kind: ProductExtensionKind!
}

type AcademiesRootTag implements AcademiesTag {
  canBeDeleted: Boolean!
  children(after: String, before: String, first: Int, last: Int): AcademiesChildTagsConnection!
  data: AcademiesTagData!
  id: ID!
  kind: AcademiesTagKind!
  subId: ID!
}

"""A connection to a list of items."""
type AcademiesRootTagsConnection {
  """A list of edges."""
  edges: [AcademiesRootTagsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type AcademiesRootTagsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: AcademiesRootTag!
}

interface AcademiesTag {
  canBeDeleted: Boolean!
  children(after: String, before: String, first: Int, last: Int): AcademiesChildTagsConnection!
  data: AcademiesTagData!
  id: ID!
  kind: AcademiesTagKind!
}

"""Data only accessible by the admin"""
type AcademiesTagAdminMutationSchema {
  createAndAppendChildTag(input: CreateAndAppendChildTagInput!): CreateAndAppendChildTagPayload
  createRootTag(input: CreateRootTagInput!): CreateRootTagPayload
  deleteTag(input: deleteTagInput!): deleteTagPayload
  editTag(input: editTagInput!): editTagPayload
}

"""Data only accessible by the admin"""
type AcademiesTagAdminSchema {
  RootTags(after: String, before: String, first: Int, isClickable: Boolean, isTopic: Boolean, last: Int, name: String): AcademiesRootTagsConnection!
  SelectTags(after: String, before: String, first: Int, isClickable: Boolean, isRoot: Boolean, isTopic: Boolean, last: Int, name: String): AcademiesTagsConnection!
}

type AcademiesTagCoordinates {
  parent: AcademiesTag
  root: AcademiesRootTag
}

type AcademiesTagData {
  isClickable: Boolean!
  isTopic: Boolean!
  name: String!
}

enum AcademiesTagKind {
  Child
  Root
}

type AcademiesTagQueries {
  AcademiesTags(after: String, before: String, first: Int, last: Int): AcademiesRootTagsConnection!
}

"""A connection to a list of items."""
type AcademiesTagsConnection {
  """A list of edges."""
  edges: [AcademiesTagsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type AcademiesTagsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: AcademiesTag!
}

type AcademiesUserExtension implements UserExtension {
  adsOptIn: Boolean!
  avatar: File
  branch: Branch
  firstLogin: Boolean!
  firstName: String!
  gamificationPoints: Int!
  kind: UserExtensionKind!
  lastName: String!
  level: Int!
  position: String
  potentialAnalysisMaxRewardAcknowledged: Boolean
  progressInPercent: Int!
  sumGamificationPoints: Int!
  teamSize: TeamSize
}

input AcceptInvitationInput {
  clientMutationId: String
  token: String!
}

type AcceptInvitationPayload {
  clientMutationId: String
}

input AcceptInviteWithNewUserInput {
  adsOptIn: Boolean!
  branch: Branch
  clientMutationId: String
  email: String!
  firstName: String!
  lastName: String!
  position: String
  rawPassword: String!
  teamSize: TeamSize
  token: String!
}

type AcceptInviteWithNewUserPayload {
  clientMutationId: String
  loginResult: LoginResult!
}

type Account implements Node {
  extension(accountExtensionKind: AccountExtensionKind!): AccountExtension
  extensions: [AccountExtension!]!
  groupAssociations: [AccountGroupAssociation!]!
  """The ID of an object"""
  id: ID!
  isDeleted: Boolean!
  name: String!
  registeredAt: ZonedDateTIme!
}

"""Data only accessible by the admin"""
type AccountBaseDataAdminMutationSchema {
  editBusinessBaseData(input: EditBusinessBaseDataAdminInput!): EditBusinessBaseDataAdminPayload
  editPrivateBaseData(input: EditPrivateBaseDataAdminInput!): EditPrivateBaseDataAdminPayload
}

"""Data only accessible by the admin"""
type AccountBaseDataAdminSchema {
  AccountBaseData(after: String, before: String, filterByAccountId: ID!, first: Int, last: Int): baseData!
}

type AccountBaseDataMutations {
  editBusinessBaseData(input: EditBusinessBaseDataInput!): EditBusinessBaseDataPayload
  editPrivateBaseData(input: EditPrivateBaseDataInput!): EditPrivateBaseDataPayload
  setAccountBaseDataCountry(input: SetAccountBaseDataCountryInput!): SetAccountBaseDataCountryPayload
}

type AccountBaseDataQueries {
  AccountBaseData: baseData!
}

"""A connection to a list of items."""
type AccountConnection {
  """A list of edges."""
  edges: [AccountEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type AccountData {
  bic: String
  iban: String!
}

input AccountDataInput {
  bic: String
  iban: String!
}

"""An edge in a connection."""
type AccountEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Account!
}

interface AccountExtension {
  kind: AccountExtensionKind!
}

enum AccountExtensionKind {
  Academies
}

type AccountGroup implements Node {
  """The ID of an object"""
  id: ID!
  isBuiltIn: Boolean!
  name: String!
  permissions: [Permission!]!
}

type AccountGroupAssignmentRule implements AssignmentRule & Node {
  accountRef: ID!
  active: Boolean!
  amountEffectedUser: Long!
  """The ID of an object"""
  id: ID!
  licenseGroupingId: ID!
  name: String!
  userInAccountGroups: [UserInAccountGroup!]!
}

type AccountGroupAssociation {
  group: AccountGroup
}

type AccountGroupProduct implements ProductData {
  accountGroupId: ID
  kind: ProductKind!
}

"""A connection to a list of items."""
type AccountGroupsConnection {
  """A list of edges."""
  edges: [AccountGroupsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type AccountGroupsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: AccountGroup!
}

interface AccountMember {
  groups: [UserInAccountGroup!]!
  id: ID!
  isManager: Boolean!
  kind: AccountMemberKind!
  name: String!
}

"""A connection to a list of items."""
type AccountMemberConnection {
  """A list of edges."""
  edges: [AccountMemberEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type AccountMemberEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: AccountMember!
}

enum AccountMemberKind {
  Invitation
  UserInAccount
}

type AccountMemberManagementMutations {
  anonymizeAccountAsOwner(input: AnonymizeAccountAsOwnerInput!): AnonymizeAccountAsOwnerPayload
  createUserInAccountGroupAndAddOrInviteUsersMutation(input: CreateUserInAccountGroupAndAddOrInviteUsersMutationInput!): CreateUserInAccountGroupAndAddOrInviteUsersMutationPayload
  deleteInvitation(input: DeleteInvitationInput!): DeleteInvitationPayload
  deleteUserInAccountGroups(input: DeleteUserInAccountGroupsInput!): DeleteUserInAccountGroupsPayload
  editUserInAccountGroupAndAddOrInviteUsersMutation(input: EditUserInAccountGroupAndAddOrInviteUsersMutationInput!): EditUserInAccountGroupAndAddOrInviteUsersMutationPayload
  inviteOrAddUsersToUserInAccountGroups(input: InviteOrAddUsersToUserInAccountGroupsInput!): InviteOrAddUsersToUserInAccountGroupsPayload
  removeUsersFromAccount(input: RemoveUsersFromAccountInput!): RemoveUsersFromAccountPayload
  removeUsersFromUserInAccountGroup(input: RemoveUsersFromUserInAccountGroupInput!): RemoveUsersFromUserInAccountGroupPayload
}

type AccountMemberManagementQueries {
  AccountMembers(filterByAccountMemberKind: AccountMemberKind, filterByGroupIds: [ID!]!, filterByNameOrEmail: String): AccountMembersResult!
  UserInAccountGroupWrapper(id: ID!): UserInAccountGroupWrapper
  UserInAccountGroupWrappers(after: String, before: String, doCalcMemberCount: Boolean!, filterByName: String, first: Int, includeOwner: Boolean!, includeUser: Boolean!, last: Int): UserInAccountGroupWrappersResult!
}

type AccountMembersResult {
  accountMembers(after: String, before: String, first: Int, last: Int): AccountMemberConnection!
  invitationCount: Long!
  userCount: Long!
}

type AccountPermissions {
  accountRef: ID!
  permissions: [Permission!]!
}

input AcknowledgePotentialAnalysisMaxRewardInput {
  clientMutationId: String
}

type AcknowledgePotentialAnalysisMaxRewardPayload {
  clientMutationId: String
}

input AcknowledgePublishingV2Input {
  clientMutationId: String
  publishingId: ID!
}

type AcknowledgePublishingV2Payload {
  clientMutationId: String
  publishing: PublishingV2!
}

input ActivateUserInput {
  clientMutationId: String
  token: String!
}

type ActivateUserPayload {
  clientMutationId: String
}

type ActiveAsyncContentSubmissionDefinition implements AsyncContentSubmissionDefinition & ContentSubmissionDefinition {
  contentKind: ContentKind!
  element: AsyncLearnElement
  status: ContentSubmissionStatus!
}

type ActiveELearningContentSubmissionDefinition implements ContentSubmissionDefinition & ELearningContentSubmissionDefinition {
  canGoToNext: Boolean!
  canGoToPrevious: Boolean!
  contentKind: ContentKind!
  currentElementState: ElementState
  progress: ELearningContentSubmissionProgress!
  relativeProgress: ELearningContentSubmissionRelativeProgress!
  status: ContentSubmissionStatus!
}

type ActiveELearningContentSubmissionProgress implements ELearningContentSubmissionProgress {
  currentElementIndex: Int!
  isAtLastElement: Boolean!
  numElements: Int!
  percentage: Int!
}

input AddAfterDateTimeVisibilityTreeConfigInput {
  clientMutationId: String
  dateTime: ZonedDateTIme!
  rootNodeId: ID!
}

type AddAfterDateTimeVisibilityTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input AddBlockPermanentlyRestartIfFailedContentConfigInput {
  clientMutationId: String
  contentNodeId: ID!
  maximumTries: Int!
}

type AddBlockPermanentlyRestartIfFailedContentConfigPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input AddBlockTemporarilyRestartIfFailedContentConfigInput {
  clientMutationId: String
  contentNodeId: ID!
  daysToBlock: Int!
}

type AddBlockTemporarilyRestartIfFailedContentConfigPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input AddCanAfterStartingTreeStartContentConfigInput {
  clientMutationId: String
  contentId: ID!
}

type AddCanAfterStartingTreeStartContentConfigPayload {
  clientMutationId: String
  content: TreeNode!
}

input AddCanIfUnlockedStartContentConfigInput {
  clientMutationId: String
  contentId: ID!
}

type AddCanIfUnlockedStartContentConfigPayload {
  clientMutationId: String
  content: TreeNode!
}

input AddCanNotRestartIfFailedContentConfigInput {
  clientMutationId: String
  contentNodeId: ID!
}

type AddCanNotRestartIfFailedContentConfigPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input AddColumnToMatrixElementInput {
  clientMutationId: String
  columnTitle: String!
  correctAnswerContent: String!
  matrixElementId: ID!
}

type AddColumnToMatrixElementPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
}

input AddCrmTreeHeadUpdaterRewardInput {
  clientMutationId: String
  contentId: ID!
}

type AddCrmTreeHeadUpdaterRewardPayload {
  clientMutationId: String
  content: TreeNode!
}

input AddDefaultFileAttachmentInput {
  clientMutationId: String
  descriptionOpt: String
  fileId: ID!
  nodeId: ID!
  titleOpt: String
}

type AddDefaultFileAttachmentPayload {
  clientMutationId: String
  node: TreeNode!
}

input AddDoNotRewardTreeConfigInput {
  clientMutationId: String
  rootNodeId: ID!
}

type AddDoNotRewardTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input AddEducationalParticipationCertificateRewardInput {
  clientMutationId: String
  contentId: ID!
  data: ParticipationCertificateRewardDataInput!
}

type AddEducationalParticipationCertificateRewardPayload {
  clientMutationId: String
  content: TreeNode!
}

input AddExternalLicenseRewardInput {
  clientMutationId: String
  contentId: ID!
  data: ExternalLicenseRewardDataInput!
}

type AddExternalLicenseRewardPayload {
  clientMutationId: String
  content: TreeNode!
}

input AddGamificationPointsFinishContentSubmissionActionToActionResultToNextActionsInput {
  actionResultToNextActionsId: ID!
  clientMutationId: String
  fieldValueKindAndIdMap: [TriggerAction_FieldValueKindAndIdMapEntryInput!]!
  name: String!
}

type AddGamificationPointsFinishContentSubmissionActionToActionResultToNextActionsPayload {
  actionResultToNextActions: TriggerAction_ActionResultToNextActions!
  clientMutationId: String
}

input AddGamificationPointsFinishContentSubmissionActionToTriggerInput {
  clientMutationId: String
  fieldValueKindAndIdMap: [TriggerAction_FieldValueKindAndIdMapEntryInput!]!
  name: String!
  triggerId: ID!
}

type AddGamificationPointsFinishContentSubmissionActionToTriggerPayload {
  clientMutationId: String
  trigger: TriggerAction_Trigger!
}

input AddHideVisibilityCoachingConfigInput {
  clientMutationId: String
  coachingOfferId: ID!
}

type AddHideVisibilityCoachingConfigPayload {
  clientMutationId: String
  coachingOffer: CoachingOffer!
}

input AddHideVisibilityTreeConfigInput {
  clientMutationId: String
  rootNodeId: ID!
}

type AddHideVisibilityTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input AddIHKCertificateFinishContentSubmissionActionToActionResultToNextActionsInput {
  actionResultToNextActionsId: ID!
  clientMutationId: String
  fieldValueKindAndIdMap: [TriggerAction_FieldValueKindAndIdMapEntryInput!]!
  name: String!
}

type AddIHKCertificateFinishContentSubmissionActionToActionResultToNextActionsPayload {
  actionResultToNextActions: TriggerAction_ActionResultToNextActions!
  clientMutationId: String
}

input AddIHKCertificateFinishContentSubmissionActionToTriggerInput {
  clientMutationId: String
  fieldValueKindAndIdMap: [TriggerAction_FieldValueKindAndIdMapEntryInput!]!
  name: String!
  triggerId: ID!
}

type AddIHKCertificateFinishContentSubmissionActionToTriggerPayload {
  clientMutationId: String
  trigger: TriggerAction_Trigger!
}

input AddIHKCertificateRewardInput {
  clientMutationId: String
  contentId: ID!
}

type AddIHKCertificateRewardPayload {
  clientMutationId: String
  content: TreeNode!
}

input AddMatchingPlacementInput {
  accountId: ID!
  clientMutationId: String
  matchingId: String!
  userId: ID!
}

type AddMatchingPlacementPayload {
  clientMutationId: String
  linkToCoachingOffer: String!
}

input AddNotAfterDateTimeVisibilityTreeConfigInput {
  clientMutationId: String
  dateTime: ZonedDateTIme!
  rootNodeId: ID!
}

type AddNotAfterDateTimeVisibilityTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input AddOnlyAZAVAccountVisibilityCoachingConfigInput {
  clientMutationId: String
  coachingOfferId: ID!
}

type AddOnlyAZAVAccountVisibilityCoachingConfigPayload {
  clientMutationId: String
  coachingOffer: CoachingOffer!
}

input AddOnlyAZAVAccountVisibilityTreeConfigInput {
  clientMutationId: String
  rootNodeId: ID!
}

type AddOnlyAZAVAccountVisibilityTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input AddOnlyAdminsVisibilityTreeConfigInput {
  clientMutationId: String
  rootNodeId: ID!
}

type AddOnlyAdminsVisibilityTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input AddOnlyBusinessAccountVisibilityCoachingConfigInput {
  clientMutationId: String
  coachingOfferId: ID!
}

type AddOnlyBusinessAccountVisibilityCoachingConfigPayload {
  clientMutationId: String
  coachingOffer: CoachingOffer!
}

input AddOnlyBusinessAccountVisibilityTreeConfigInput {
  clientMutationId: String
  rootNodeId: ID!
}

type AddOnlyBusinessAccountVisibilityTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input AddOnlyEditorsVisibilityTreeConfigInput {
  clientMutationId: String
  rootNodeId: ID!
}

type AddOnlyEditorsVisibilityTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input AddOnlyIfTreeStateVisibilityTreeConfigInput {
  clientMutationId: String
  rootNodeId: ID!
}

type AddOnlyIfTreeStateVisibilityTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input AddOnlyWithLicenseVisibilityCoachingConfigInput {
  clientMutationId: String
  coachingOfferId: ID!
}

type AddOnlyWithLicenseVisibilityCoachingConfigPayload {
  clientMutationId: String
  coachingOffer: CoachingOffer!
}

input AddOrderItemInput {
  clientMutationId: String
  orderElementId: ID!
  text: String!
}

type AddOrderItemPayload {
  clientMutationId: String
  orderElement: OrderElement!
}

input AddParticipantAdminInput {
  availabilityId: ID!
  clientMutationId: String
  participantId: ID!
}

type AddParticipantAdminPayload {
  availability: Availability!
  clientMutationId: String
}

input AddParticipantToBookingAsCoachInput {
  availabilityId: ID!
  clientMutationId: String
  participantId: ID!
}

type AddParticipantToBookingAsCoachPayload {
  availability: Availability!
  clientMutationId: String
}

input AddParticipantToMyBookingInput {
  availabilityId: ID!
  clientMutationId: String
  participantId: ID!
}

type AddParticipantToMyBookingPayload {
  availability: Availability!
  clientMutationId: String
}

input AddProductSelectionConditionInput {
  amount: Int!
  clientMutationId: String
  limitedCartDiscountId: ID!
  productId: ID!
}

type AddProductSelectionConditionPayload {
  clientMutationId: String
  limitedCartDiscount: LimitedCartDiscount!
}

input AddRowToMatrixElementInput {
  clientMutationId: String
  correctAnswerContent: String!
  matrixElementId: ID!
  rowTitle: String!
}

type AddRowToMatrixElementPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
}

input AddUserToAccountAdminInput {
  accountId: ID!
  clientMutationId: String
  userId: ID!
}

type AddUserToAccountAdminPayload {
  clientMutationId: String
  userInAccount: UserInAccountEdge!
}

input AddWordNoteInput {
  clientMutationId: String
  note: String!
  wordId: ID!
}

type AddWordNotePayload {
  clientMutationId: String
  inventory: WordInventory!
}

input AddWordPackageRewardInput {
  clientMutationId: String
  contentId: ID!
  data: WordPackageRewardDataInput!
}

type AddWordPackageRewardPayload {
  clientMutationId: String
  content: TreeNode!
}

input AddWordProficienciesRewardInput {
  clientMutationId: String
  contentId: ID!
}

type AddWordProficienciesRewardPayload {
  clientMutationId: String
  content: TreeNode!
}

input AddWordToPackageInput {
  clientMutationId: String
  explanation: String!
  translation: String
  word: String!
  wordPackageId: ID!
}

type AddWordToPackagePayload {
  clientMutationId: String
  wordPackage: WordPackage!
}

input AddWrongAnswerInMatrixElementCellInput {
  clientMutationId: String
  matrixCellId: ID!
  matrixElementId: ID!
  wrongAnswerContent: String!
}

type AddWrongAnswerInMatrixElementCellPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
}

type Address {
  city: String!
  lineOne: String!
  lineTwo: String!
  postalCode: String!
}

input AddressInput {
  city: String!
  lineOne: String!
  lineTwo: String!
  postalCode: String!
}

"""Data only accessible by the admin"""
type AdminMutationType {
  AcademiesTag: AcademiesTagAdminMutationSchema!
  AccountBaseData: AccountBaseDataAdminMutationSchema!
  AsyncContent: AsyncContentAdminMutationSchema!
  Auth: AuthAdminMutationSchema!
  AvgsPotentialAnalysis: AvgsPotentialAnalysisAdminMutationSchema!
  Azav: AzavAdminMutationSchema!
  Billing: BillingAdminMutationSchema!
  Caching: CachingAdminMutationSchema!
  Coaching: CoachingAdminMutationSchema!
  CustomerFeedback: CustomerFeedbackAdminMutationSchema!
  ElearningV2: ElearningV2AdminMutationSchema!
  Email: EmailAdminMutationSchema!
  FeatureToggle: FeatureToggleAdminMutationSchema!
  Files: FilesAdminMutationSchema!
  Hubspot: HubspotAdminMutationSchema!
  Instructor: InstructorAdminMutationSchema!
  LearnV2: LearnV2AdminMutationSchema!
  LicenseDefinition: LicenseDefinitionAdminMutationSchema!
  Notification: NotificationAdminMutationSchema!
  PublishingV2: PublishingV2AdminMutationSchema!
  Settings: SettingsAdminMutationSchema!
  Staging: StagingAdminMutationSchema!
  Tag: TagAdminMutationSchema!
  Tree: TreeAdminMutationSchema!
  Trend: TrendAdminMutationSchema!
  TriggerAction: TriggerActionAdminMutationSchema!
  VimeoVideoSource: VimeoVideoSourceAdminMutationSchema!
  Vocab: VocabAdminMutationSchema!
}

"""Data only accessible by the admin"""
type AdminQueryType {
  AcademiesTag: AcademiesTagAdminSchema!
  AccountBaseData: AccountBaseDataAdminSchema!
  AsyncContent: AsyncContentAdminSchema!
  Auth: AuthAdminSchema!
  AvgsPotentialAnalysis: AvgsPotentialAnalysisAdminSchema!
  Billing: BillingAdminSchema!
  Coaching: CoachingAdminSchema!
  Email: EmailAdminSchema!
  FeatureToggle: FeatureToggleAdminSchema!
  Files: FilesAdminSchema!
  Instructor: InstructorAdminSchema!
  LearnV2: LearnV2AdminSchema!
  Learnable: LearnableAdminSchema!
  LicenseDefinition: LicenseDefinitionAdminSchema!
  Management: ManagementAdminSchema!
  Notification: NotificationAdminSchema!
  PublishingV2: PublishingV2AdminSchema!
  Reports: ReportsAdminSchema!
  Settings: SettingsAdminSchema!
  Tag: TagAdminSchema!
  Tree: TreeAdminSchema!
  Trend: TrendAdminSchema!
  TriggerAction: TriggerActionAdminSchema!
  VimeoVideoSource: VimeoVideoSourceAdminSchema!
  Vocab: VocabAdminSchema!
}

type Advantage {
  description: String!
  heading: String!
  icon: Icon
}

input AdvantageInput {
  description: String!
  heading: String!
  icon: Icon
}

type AfterDateTimeVisibilityTreeConfig implements VisibilityTreeConfig {
  configType: VisibilityTreeConfigType!
  dateTime: ZonedDateTIme!
  """The ID of an object"""
  id: ID!
}

type AlwaysPassContentConfig implements PassContentConfig {
  configType: PassContentConfigType!
  """The ID of an object"""
  id: ID!
}

type AlwaysRestartContinueContentConfig implements ContinueContentConfig {
  configType: ContinueContentConfigType!
  """The ID of an object"""
  id: ID!
}

input AnonymizeAccountAsOwnerInput {
  clientMutationId: String
}

type AnonymizeAccountAsOwnerPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input AnonymizeAccountInput {
  clientMutationId: String
  id: ID!
}

type AnonymizeAccountPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input AnonymizeMyUserInput {
  clientMutationId: String
}

type AnonymizeMyUserPayload {
  clientMutationId: String
}

type AnswerMatrixElementCell implements MatrixElementCell {
  correctAnswer: MatrixElementCellCorrectAnswer!
  """The ID of an object"""
  id: ID!
  kind: MatrixElementCellKind!
  wrongAnswers: [MatrixElementCellWrongAnswer!]!
  xIdx: Int!
  yIdx: Int!
}

type AnswerMatrixLearnElementCell implements MatrixLearnElementCell {
  answers: [MatrixLearnElementAnswer!]!
  kind: MatrixElementCellKind!
  xIdx: Int!
  yIdx: Int!
}

type AnswerOptionV2 {
  answer: String!
  image: File
  isCorrect: Boolean!
}

input AnswerOptionV2Input {
  answer: String!
  imageRef: ID
  isCorrect: Boolean!
}

type AnswerOptionWithoutCorrect {
  answer: String!
  image: File
}

enum AnsweringTypeV2 {
  allowMultipleAnswersAllCorrectMustBeGiven
  allowMultipleAnswersOnlySomeCorrectMustBeGiven
  allowOnlyOneAnswer
}

type AppleIAPData implements PaymentProviderData {
  dataType: PaymentProviderDataType!
  paymentMethod: PaymentMethodType!
  receipt: String!
}

interface AssignmentRule {
  accountRef: ID!
  """The ID of an object"""
  id: ID!
  licenseGroupingId: ID!
}

"""Data only accessible by the admin"""
type AsyncContentAdminMutationSchema {
  createUploadAsyncElement(input: CreateUploadAsyncElementInput!): CreateUploadAsyncElementPayload
  editUploadAsyncElement(input: EditUploadAsyncElementInput!): EditUploadAsyncElementPayload
  evaluateUploadAsyncElementTask(input: EvaluateUploadAsyncElementTaskInput!): EvaluateUploadAsyncElementTaskPayload
}

"""Data only accessible by the admin"""
type AsyncContentAdminSchema {
  GetAsyncElementTasks(after: String, before: String, first: Int, last: Int): AsyncElementTasksConnection!
}

type AsyncContentMutations {
  submitUploadAsyncElement(input: SubmitUploadAsyncElementInput!): SubmitUploadAsyncElementPayload
}

interface AsyncContentSubmissionDefinition {
  contentKind: ContentKind!
  element: AsyncLearnElement
  status: ContentSubmissionStatus!
}

type AsyncContentTypeDefinition implements ContentTypeDefinition & TypeDefinition {
  contentKind: ContentKind!
  continueConfig: ContinueContentConfig!
  definitionType: TypeDefinitionType!
  element: AsyncElement
  extension: ContentExtension!
  passConfig: PassContentConfig!
  restartIfFailedConfigs: [RestartIfFailedContentConfig!]!
  restartIfPassedConfig: RestartIfPassedContentConfig!
  rewardConfig: RewardContentConfig!
  rewards: [Reward!]!
  startConfigs: [StartContentConfig!]!
  trigger: TriggerAction_Trigger
}

interface AsyncElement {
  assignedEvaluator: User
  """The ID of an object"""
  id: ID!
  kind: AsyncElementKind!
  taskDescription: String
  title: String!
}

enum AsyncElementKind {
  Upload
}

interface AsyncElementTask {
  assignedEvaluator: User
  elementKind: AsyncElementKind!
  extension: AsyncElementTaskExtension!
  id: ID!
  status: AsyncElementTaskStatus!
  submissionInfo: AsyncElementTaskSubmissionInfo!
}

interface AsyncElementTaskExtension {
  doNotUse: String!
}

type AsyncElementTaskExtensionImpl implements AsyncElementTaskExtension {
  doNotUse: String!
  hierarchy: AsyncElementTaskHierarchy
}

type AsyncElementTaskHierarchy {
  asyncContentTitle: String!
  branchTitle: String!
  rootTitle: String!
}

enum AsyncElementTaskStatus {
  Evaluated
  Fresh
}

type AsyncElementTaskSubmissionInfo {
  at: ZonedDateTIme!
  by: User
}

"""A connection to a list of items."""
type AsyncElementTasksConnection {
  """A list of edges."""
  edges: [AsyncElementTasksEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type AsyncElementTasksEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: AsyncElementTask!
}

interface AsyncLearnElement {
  elementKind: AsyncElementKind!
  """The ID of an object"""
  id: ID!
  taskDescription: String!
  title: String!
}

enum AttachmentKind {
  DefaultFile
}

interface AttachmentV2 {
  description: String
  """The ID of an object"""
  id: ID!
  kind: AttachmentKind!
  title: String
}

"""Data only accessible by the admin"""
type AuthAdminMutationSchema {
  addUserToAccount(input: AddUserToAccountAdminInput!): AddUserToAccountAdminPayload
  anonymizeAccountAdmin(input: AnonymizeAccountInput!): AnonymizeAccountPayload
  anonymizeUser(input: DeleteUserInput!): DeleteUserPayload
  createAccount(input: CreateAccountInput!): CreateAccountPayload
  createUserInAccount(input: CreateUserInAccountInput!): CreateUserInAccountPayload
  editUser(input: EditUserInput!): EditUserPayload
  loginAsUserJwt(input: LoginAsUserJwtInput!): LoginAsUserJwtPayload
  removeUserFromAccount(input: RemoveUserFromAccountInput!): RemoveUserFromAccountPayload
  setAccountGroups(input: SetAccountGroupsInput!): SetAccountGroupsPayload
  setAccountName(input: SetAccountNameInput!): SetAccountNamePayload
  setUserInAccountGroups(input: SetUserInAccountGroupsInput!): SetUserInAccountGroupsPayload
  triggerResendActivation(input: TriggerResendActivationInput!): TriggerResendActivationPayload
  triggerResetPassword(input: TriggerResetPasswordInput!): TriggerResetPasswordPayload
}

"""Data only accessible by the admin"""
type AuthAdminSchema {
  Accounts(after: String, before: String, first: Int, last: Int, name: String): AccountConnection!
  GetUserInAccountGroups(id: ID!): [UserInAccountGroup!]!
  SearchEditors(after: String, before: String, filterByNameOrEmail: String, first: Int, last: Int): UserConnection!
  SelectAccounts(after: String, before: String, first: Int, ids: [ID!]!, last: Int, nameOpt: String): AccountConnection!
  SelectUsers(after: String, before: String, filterByAccountId: ID, filterByNameOrEmail: String, first: Int, last: Int): UserConnection!
  Users(after: String, before: String, filterByAccountId: ID, filterByNameOrEmail: String, first: Int, last: Int): UserConnection!
}

type AuthMutations {
  acceptInvitation(input: AcceptInvitationInput!): AcceptInvitationPayload
  acceptInvitationWithNewUser(input: AcceptInviteWithNewUserInput!): AcceptInviteWithNewUserPayload
  activateUser(input: ActivateUserInput!): ActivateUserPayload
  forgotPassword(input: ForgotPasswordInput!): ForgotPasswordPayload
  leaveAccount(input: LeaveAccountInput!): LeaveAccountPayload
  login(input: LoginInput!): LoginPayload
  loginJwt(input: LoginJwtInput!): LoginJwtPayload
  logoutJwt(input: LogoutJwtInput!): LogoutJwtPayload
  registerUser(input: RegisterUserInput!): RegisterUserPayload
  resendActivation(input: ResendActivationInput!): ResendActivationPayload
  resetPasswordAndActivate(input: ResetPasswordAndActivateInput!): ResetPasswordAndActivatePayload
  setAccountNameUser(input: SetAccountNameUserInput!): SetAccountNameUserPayload
  switchAccount(input: SwitchAccountInput!): SwitchAccountPayload
}

type AuthQueries {
  InvitationByToken(token: String!): Invitation
}

"""Data partaining to the current user"""
type AuthViewerMutationSchema {
  anonymizeMyUser(input: AnonymizeMyUserInput!): AnonymizeMyUserPayload
}

"""Data partaining to the current user"""
type AuthViewerSchema {
  currentUser: CurrentUser
}

type Availability implements Node {
  booking: BookingInterface!
  coachProfile: CoachProfile
  data: AvailabilityData!
  feedback: CoachFeedback
  """The ID of an object"""
  id: ID!
}

"""A connection to a list of items."""
type AvailabilityConnection {
  """A list of edges."""
  edges: [AvailabilityEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type AvailabilityData {
  endDateTime: ZonedDateTIme!
  startDateTime: ZonedDateTIme!
}

input AvailabilityDataInput {
  endDateTime: ZonedDateTIme!
  startDateTime: ZonedDateTIme!
}

"""An edge in a connection."""
type AvailabilityEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Availability!
}

type AvailabilitySchedule implements Node {
  coachRef: ID!
  data: ScheduleData!
  """The ID of an object"""
  id: ID!
}

"""A connection to a list of items."""
type AvailabilityScheduleConnection {
  """A list of edges."""
  edges: [AvailabilityScheduleEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type AvailabilityScheduleDayAndTimes {
  dayOfWeek: DayOfWeek!
  timeSlots: [LocalTime!]!
}

"""An edge in a connection."""
type AvailabilityScheduleEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: AvailabilitySchedule!
}

"""Data only accessible by the admin"""
type AvgsPotentialAnalysisAdminMutationSchema {
  changeInvitedForUser(input: ChangeInvitedForUserInput!): ChangeInvitedForUserPayload
  changeReplacementCoach(input: ChangeReplacementCoachInput!): ChangeReplacementCoachPayload
  createPotentialAnalysis(input: CreatePotentialAnalysisInput!): CreatePotentialAnalysisPayload
  transformBusinessAccountToAVGSAccount(input: TransformBusinessAccountToAVGSAccountInput!): TransformBusinessAccountToAVGSAccountPayload
  transformPrivateAccountToAVGSAccount(input: TransformPrivateAccountToAVGSAccountInput!): TransformPrivateAccountToAVGSAccountPayload
}

"""Data only accessible by the admin"""
type AvgsPotentialAnalysisAdminSchema {
  AVGSPotentialAnalysis(after: String, before: String, first: Int, last: Int): PotentialAnalysisConnection!
  AvailableModulesAndDimensions(after: String, before: String, first: Int, last: Int): [AVGSPotentialAnalysis_Module!]!
  Info: AVGSPotentialAnalysis_Info
  SearchAVGSCoaches(accountId: ID!, after: String, before: String, filterByNameOrEmail: String, first: Int, last: Int): UserConnection!
}

type AvgsPotentialAnalysisMutations {
  setAnswerInMultipleChoiceFreeTextQuestion(input: SetAnswerInMultipleChoiceFreeTextQuestionInput!): SetAnswerInMultipleChoiceFreeTextQuestionPayload
  setAnswerInMultipleChoiceQuestion(input: SetAnswerInMultipleChoiceQuestionInput!): SetAnswerInMultipleChoiceQuestionPayload
  setAnswerInScaleQuestion(input: SetAnswerInScaleQuestionInput!): SetAnswerInScaleQuestionPayload
  setAnswerInSingleChoiceFreeTextQuestion(input: SetAnswerInSingleChoiceFreeTextQuestionInput!): SetAnswerInSingleChoiceFreeTextQuestionPayload
  setAnswerInSingleChoiceQuestion(input: SetAnswerInSingleChoiceQuestionInput!): SetAnswerInSingleChoiceQuestionPayload
  setAnswerInTextQuestion(input: SetAnswerInTextQuestionInput!): SetAnswerInTextQuestionPayload
}

type AvgsPotentialAnalysisQueries {
  AVGSAccounts(after: String, before: String, filterByName: String, first: Int, last: Int): AccountConnection!
  LearnPotentialAnalysis(after: String, before: String, first: Int, last: Int, learnPotentialAnalysisId: ID!): AVGSPotentialAnalysis_LearnPotentialAnalysis
}

"""Data only accessible by the admin"""
type AzavAdminMutationSchema {
  transformBusinessAccountToAZAVAccount(input: TransformBusinessAccountToAZAVAccountInput!): TransformBusinessAccountToAZAVAccountPayload
  transformPrivateAccountToAZAVAccount(input: TransformPrivateAccountToAZAVAccountInput!): TransformPrivateAccountToAZAVAccountPayload
}

type BaseData {
  address: Address!
  birthDate: LocalDate!
  birthPlace: String!
  gender: Gender!
  nationality: String!
}

"""
The `BigDecimal` scalar type represents signed fractional values with arbitrary precision.
"""
scalar BigDecimal

"""Data only accessible by the admin"""
type BillingAdminMutationSchema {
  addProductSelectionCondition(input: AddProductSelectionConditionInput!): AddProductSelectionConditionPayload
  createAccountGroupProduct(input: CreateAccountGroupProductInput!): CreateAccountGroupProductPayload
  createContractPartner(input: CreateContractPartnerInput!): CreateContractPartnerPayload
  createDiscountCode(input: CreateDiscountCodeInput!): CreateDiscountCodePayload
  createEuroDiscountAction(input: CreateEuroDiscountActionInput!): CreateEuroDiscountActionPayload
  createExternalLicense(input: CreateExternalLicenseInput!): CreateExternalLicensePayload
  createExternalLicensePool(input: CreateExternalLicensePoolInput!): CreateExternalLicensePoolPayload
  createLicenseProduct(input: CreateLicenseProductInput!): CreateLicenseProductPayload
  createLicenseUsageReport(input: CreateLicenseUsageReportInput!): CreateLicenseUsageReportPayload
  createLicenses(input: CreateLicensesInput!): CreateLicensesPayload
  createLimitedCartDiscount(input: CreateLimitedCartDiscountInput!): CreateLimitedCartDiscountPayload
  createPercentageDiscountAction(input: CreatePercentageDiscountActionInput!): CreatePercentageDiscountActionPayload
  createPlacementProduct(input: CreatePlacementProductInput!): CreatePlacementProductPayload
  createRandomDiscountCodes(input: CreateRandomDiscountCodesInput!): CreateRandomDiscountCodesPayload
  createStripeConnectAccount(input: CreateStripeConnectAccountInput!): CreateStripeConnectAccountPayload
  createTransfersReport(input: CreateTransfersReportInput!): CreateTransfersReportPayload
  deleteCondition(input: DeleteConditionInput!): DeleteConditionPayload
  deleteContractPartner(input: DeleteContractPartnerInput!): DeleteContractPartnerPayload
  deleteDiscountAction(input: DeleteDiscountActionInput!): DeleteDiscountActionPayload
  deleteDiscountCode(input: DeleteDiscountCodeInput!): DeleteDiscountCodePayload
  deleteExternalLicense(input: DeleteExternalLicenseInput!): DeleteExternalLicensePayload
  deleteExternalLicensePool(input: DeleteExternalLicensePoolInput!): DeleteExternalLicensePoolPayload
  deleteLicense(input: DeleteLicenseInput!): DeleteLicensePayload
  deleteLimitedCartDiscount(input: DeleteLimitedCartDiscountInput!): DeleteLimitedCartDiscountPayload
  deleteProduct(input: DeleteProductInput!): DeleteProductPayload
  editAcademiesProductExtension(input: EditAcademiesProductExtensionInput!): EditAcademiesProductExtensionPayload
  editAccountGroupProduct(input: EditAccountGroupProductInput!): EditAccountGroupProductPayload
  editContractPartnerData(input: EditContractPartnerDataInput!): EditContractPartnerDataPayload
  editDiscountCode(input: EditDiscountCodeInput!): EditDiscountCodePayload
  editEuroDiscountAction(input: EditEuroDiscountActionInput!): EditEuroDiscountActionPayload
  editExternalLicense(input: EditExternalLicenseInput!): EditExternalLicensePayload
  editExternalLicensePool(input: EditExternalLicensePoolInput!): EditExternalLicensePoolPayload
  editLicenseProduct(input: EditLicenseProductInput!): EditLicenseProductPayload
  editLimitedCartDiscount(input: EditLimitedCartDiscountInput!): EditLimitedCartDiscountPayload
  editPercentageDiscountAction(input: EditPercentageDiscountActionInput!): EditPercentageDiscountActionPayload
  editProduct(input: EditProductInput!): EditProductPayload
  editProductSelectionCondition(input: EditProductSelectionConditionInput!): EditProductSelectionConditionPayload
  generateAbsoluteCartLink(input: GenerateAbsoluteCartLinkInput!): GenerateAbsoluteCartLinkPayload
  issueExternalLicense(input: IssueExternalLicenseInput!): IssueExternalLicensePayload
}

"""Data only accessible by the admin"""
type BillingAdminSchema {
  ContractPartners(after: String, before: String, first: Int, last: Int, name: String): ContractPartnersConnection!
  DiscountActions(after: String, before: String, filterByActionTitle: String, filterByCode: String, filterByDiscountTypeKind: DiscountTypeKindInput, first: Int, last: Int): DiscountActionsConnection!
  DiscountsMultiselect(after: String, before: String, codeOpt: String, first: Int, ids: [ID!]!, last: Int): DiscountCodesV2Connection!
  GetExternalLicensePools(after: String, before: String, first: Int, last: Int, nameOpt: String): ExternalLicensePoolsConnection!
  GetExternalLicenses(after: String, before: String, first: Int, isIssued: Boolean, last: Int, name: String, pool: ID): ExternalLicensesConnection!
  LimitedCartDiscounts(after: String, before: String, first: Int, last: Int, title: String): LimitedCartDiscountConnection!
  Orders(accountId: ID, after: String, before: String, email: String, first: Int, last: Int, userId: ID, username: String): OrdersConnection!
  SearchProducts(after: String, before: String, first: Int, inKinds: [ProductKind!]!, isHiddenOpt: Boolean, last: Int, titleOpt: String): ProductsConnection!
  selectDiscountCodes(after: String, before: String, code: String, first: Int, last: Int): DiscountCodesV2Connection!
}

interface BillingDetails {
  city: String!
  country: String!
  customerType: CustomerType!
  firstName: String!
  houseNumber: String!
  invoiceEmail: String!
  lastName: String!
  phoneNumber: String!
  postalCode: String!
  salutation: SalutationType!
  street: String!
}

type BillingDetailsUpdate implements HistoryEventInterface {
  kind: HistoryEventType!
}

type BillingMutations {
  bookTree(input: BookTreeInput!): BookTreePayload
  changePaymentDate(input: ChangePaymentDateInput!): ChangePaymentDatePayload
  changePaymentMethod(input: ChangePaymentMethodInput!): ChangePaymentMethodPayload
  createOrder(input: CreateOrderInput!): CreateOrderPayload
  payOrder(input: PayOrderInput!): PayOrderPayload
  payOrderViaIAP(input: PayOrderViaIAPInput!): PayOrderViaIAPPayload
  updateBusinessBillingDetails(input: UpdateBusinessBillingDetailsInput!): UpdateBusinessBillingDetailsPayload
  updateBusinessBillingDetailsAndInitiateCheckout(input: UpdateBusinessBillingDetailsAndInitiateCheckoutInput!): UpdateBusinessBillingDetailsAndInitiateCheckoutPayload
  updateCart(input: UpdateCartInput!): UpdateCartPayload
  updatePrivateBillingDetails(input: UpdatePrivateBillingDetailsInput!): UpdatePrivateBillingDetailsPayload
  updatePrivateBillingDetailsAndInitiateCheckout(input: UpdatePrivateBillingDetailsAndInitiateCheckoutInput!): UpdatePrivateBillingDetailsAndInitiateCheckoutPayload
}

"""Data partaining to the current user"""
type BillingViewerSchema {
  LicensesGroupedByDefinition(after: String, before: String, first: Int, last: Int): LicensesGroupedByDefinitionConnection!
  ViewerOrders(after: String, before: String, first: Int, last: Int): OrdersConnection!
}

type BlockPermanentlyRestartIfFailedContentConfig implements RestartIfFailedContentConfig {
  configType: RestartIfFailedContentConfigType!
  """The ID of an object"""
  id: ID!
  maximumTries: Int!
}

type BlockTemporarilyRestartIfFailedContentConfig implements RestartIfFailedContentConfig {
  configType: RestartIfFailedContentConfigType!
  daysToBlock: Int!
  """The ID of an object"""
  id: ID!
}

type BlockedByTreeContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  status: ContentNodeAdvancementStatus!
}

type BlockoutDate {
  from: ZonedDateTIme!
  to: ZonedDateTIme!
}

input BlockoutDateInput {
  from: ZonedDateTIme!
  to: ZonedDateTIme!
}

input BookCoachingInput {
  availabilityId: ID!
  clientMutationId: String
  coachingId: ID!
}

type BookCoachingPayload {
  availability: Availability!
  clientMutationId: String
}

input BookTreeInput {
  clientMutationId: String
  rootId: ID!
}

type BookTreePayload {
  clientMutationId: String
  root: LearnOpportunityV2!
}

type BookedForGroup implements BookingInterface {
  kind: BookingKind!
  msTeamsLink: String!
  offer: CoachingOffer
  participants: [Participant!]!
}

type BookedOneToOne implements BookingInterface {
  kind: BookingKind!
  msTeamsLink: String!
  offer: CoachingOffer
  participant: Participant!
}

interface BookingInterface {
  kind: BookingKind!
}

enum BookingKind {
  BookedForGroup
  BookedOneToOne
  NotBooked
}

enum Branch {
  adviceAndConsulting
  analysisAndStatistic
  financeAccountingAndControlling
  graphicsAndDesign
  healthMedicineAndSocialAffairs
  itAndSoftwareDevelopment
  legalServices
  marketingAndAdvertising
  otherFieldsOfActivity
  personnelAndHr
  processPlanningAndQualityAssurance
  productManagement
}

type BranchTypeDefinition implements TypeDefinition {
  childRefs: [ID!]!
  definitionType: TypeDefinitionType!
}

type BusinessBaseData implements baseData {
  accountData: AccountData
  billingOffice: String
  city: String
  companyLegalForm: CompanyType
  companyName: String
  countryCode: CountryCode
  houseNumber: String
  invoiceEmail: String
  phoneNumber: String
  postalCode: String
  street: String
  taxData: TaxData
}

input BusinessBaseDataInput {
  accountData: AccountDataInput!
  billingOffice: String!
  city: String!
  companyLegalForm: CompanyType!
  companyName: String!
  countryCode: CountryCode!
  houseNumber: String!
  invoiceEmail: String!
  phoneNumber: String!
  postalCode: String!
  street: String!
  taxData: TaxDataInput!
}

type BusinessBaseDataOutput {
  accountData: AccountData!
  accountName: String!
  billingOffice: String!
  city: String!
  companyLegalForm: CompanyType!
  companyName: String!
  countryCode: CountryCode!
  houseNumber: String!
  invoiceEmail: String!
  phoneNumber: String!
  postalCode: String!
  street: String!
  taxData: TaxData!
}

type BusinessBillingDetails implements BillingDetails {
  city: String!
  company: String!
  companyDetails: String
  companyType: CompanyType!
  country: String!
  customerType: CustomerType!
  firstName: String!
  houseNumber: String!
  invoiceEmail: String!
  lastName: String!
  phoneNumber: String!
  postalCode: String!
  salutation: SalutationType!
  street: String!
  taxIdentificationNumber: String
}

type BusinessData {
  bic: String
  employerNumber: String
  iban: String
  insuranceNumber: String
  taxNumber: String
}

input BusinessDataInput {
  bic: String
  employerNumber: String
  iban: String
  insuranceNumber: String
  taxNumber: String
}

"""Data only accessible by the admin"""
type CachingAdminMutationSchema {
  clearCache(input: ClearCacheInput!): ClearCachePayload
}

type CalendarWeekAndYear {
  calendarWeek: Int!
  calendarYear: Int!
}

type CanAfterStartingTreeStartContentConfig implements StartContentConfig {
  configType: StartContentConfigType!
  """The ID of an object"""
  id: ID!
}

type CanBeRestartedAfterFailedContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  status: ContentNodeAdvancementStatus!
}

type CanBeRestartedAfterPassedContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  status: ContentNodeAdvancementStatus!
}

type CanBeStartedContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  status: ContentNodeAdvancementStatus!
}

type CanBeStartedViewerTreeState implements ViewerTreeState {
  kind: ViewerTreeStateKind!
}

type CanIfInTreeFlowStartContentConfig implements StartContentConfig {
  configType: StartContentConfigType!
  """The ID of an object"""
  id: ID!
}

type CanIfUnlockedStartContentConfig implements StartContentConfig {
  configType: StartContentConfigType!
  """The ID of an object"""
  id: ID!
}

type CanNotBeRestartedAfterFailedContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  configResults: [RestartIfFailedContentConfigResult!]!
  status: ContentNodeAdvancementStatus!
}

type CanNotBeRestartedAfterPassedContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  reasonConfigTypes: [RestartIfPassedContentConfigType!]!
  status: ContentNodeAdvancementStatus!
}

type CanNotBeStartedContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  reasonConfigTypes: [StartContentConfigType!]!
  status: ContentNodeAdvancementStatus!
}

type CanNotBeStartedViewerTreeState implements ViewerTreeState {
  kind: ViewerTreeStateKind!
  reasonConfigTypes: [StartTreeConfigType!]!
}

type CanNotRestartIfFailedContentConfig implements RestartIfFailedContentConfig {
  configType: RestartIfFailedContentConfigType!
  """The ID of an object"""
  id: ID!
}

type CanNotRestartIfPassedContentConfig implements RestartIfPassedContentConfig {
  configType: RestartIfPassedContentConfigType!
  """The ID of an object"""
  id: ID!
}

type CanNotStartContentConfig implements StartContentConfig {
  configType: StartContentConfigType!
  """The ID of an object"""
  id: ID!
}

type CanNotStartTreeConfig implements StartTreeConfig {
  configType: StartTreeConfigType!
  """The ID of an object"""
  id: ID!
}

type CanRestartIfPassedContentConfig implements RestartIfPassedContentConfig {
  configType: RestartIfPassedContentConfigType!
  """The ID of an object"""
  id: ID!
}

input CanShowElementAnswerInput {
  clientMutationId: String
  contentSubmissionId: ID!
}

type CanShowElementAnswerPayload {
  can: Boolean!
  clientMutationId: String
}

input CanSubmitElementInput {
  clientMutationId: String
  contentSubmissionId: ID!
  elementId: ID!
}

type CanSubmitElementPayload {
  can: Boolean!
  clientMutationId: String
}

input CancelBookingAsCoachInput {
  availabilityId: ID!
  cancellationComment: String
  clientMutationId: String
}

type CancelBookingAsCoachPayload {
  availability: Availability!
  clientMutationId: String
}

input CancelBookingAsParticipantInput {
  availabilityId: ID!
  clientMutationId: String
}

type CancelBookingAsParticipantPayload {
  availability: Availability!
  clientMutationId: String
}

type Cart {
  discountCodeRefusals: [Refusal!]!
  items: [Item!]!
  otherAvailableProducts(after: String, before: String, first: Int, last: Int): ProductsConnection!
  paymentDates: [ZonedDateTIme!]!
  selection: Selection!
  taxTotals: TaxTotals
  totals: CartTotals!
}

type CartBulkDiscount implements Item {
  discountPercentage: BigDecimal!
  eligibleProductCount: Int!
  itemType: ItemType!
}

type CartClickout {
  absoluteLink: String!
  relativeLink: String!
}

type CartDiscount implements Item {
  code: String!
  itemType: ItemType!
  title: String!
  validUntil: ZonedDateTIme
  value: DiscountActionCalcType!
}

type CartGlobalDiscount implements Item {
  itemType: ItemType!
  title: String!
  value: DiscountActionCalcType!
}

type CartLimitedDiscount implements Item {
  itemType: ItemType!
  title: String!
  value: DiscountActionCalcType!
}

input CartLinkProductsInput {
  amount: Int!
  productId: ID!
}

type CartProduct implements Item {
  amount: Int!
  individualPrice: Price!
  itemType: ItemType!
  product: Product
  totalPrice: Price!
}

input CartSelectionInput {
  createdByUser: ID
  selectedDiscountCodes: [String!]!
  selectedProducts: [SelectedProductInput!]!
}

type CartTotals {
  appliedDiscount: Price
  appliedDiscountPercentage: BigDecimal
  appliedMoneyDiscount: BigDecimal
  includingAllDiscounts: Price!
  monthlyOptions: [MonthlyOption!]!
  withoutDiscounts: Price!
}

type CartUpdate implements HistoryEventInterface {
  kind: HistoryEventType!
}

type CategoryResult {
  benchmark: Float
  name: String!
  result: Float
}

input ChangeInvitedForUserInput {
  clientMutationId: String
  newClientEmail: String!
  potentialAnalysisId: ID!
}

type ChangeInvitedForUserPayload {
  clientMutationId: String
  potentialAnalysis: AVGSPotentialAnalysis_PotentialAnalysis!
}

input ChangePaymentDateInput {
  clientMutationId: String
  orderId: ID!
  paymentDate: ZonedDateTIme!
}

type ChangePaymentDatePayload {
  clientMutationId: String
  order: Order!
}

input ChangePaymentMethodInput {
  clientMutationId: String
  orderId: ID!
  paymentMethodType: PaymentMethodType!
  paymentType: PaymentType!
  rateCount: Int
}

type ChangePaymentMethodPayload {
  clientMutationId: String
  order: Order!
}

input ChangeReplacementCoachInput {
  clientMutationId: String
  newReplacementCoachId: ID
  potentialAnalysisId: ID!
}

type ChangeReplacementCoachPayload {
  clientMutationId: String
  edge: PotentialAnalysisEdge!
}

type ChildStructureDefinition implements StructureDefinition {
  coordinates: CoordinatesV2!
  definitionType: StructureType!
  title: String!
}

input CleanUpUserInputRelatedToStagingInput {
  clientMutationId: String
}

type CleanUpUserInputRelatedToStagingPayload {
  clientMutationId: String
}

input ClearCacheInput {
  clientMutationId: String
}

type ClearCachePayload {
  clientMutationId: String
}

input CloneTreeInput {
  clientMutationId: String
  rootNodeId: ID!
}

type CloneTreePayload {
  clientMutationId: String
  clonedRootNode: TreeNodesEdge!
}

type ClozeAnswer {
  """The ID of an object"""
  id: ID!
  text: String!
}

type ClozePart implements ClozeTextPart {
  """The ID of an object"""
  id: ID!
  kind: ClozeTextPartKind!
}

type ClozeTextElementV2 implements ElementV2 {
  additionalWords: [String!]!
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  text: String!
  title: String!
}

type ClozeTextInputElementState implements ElementState & InputElementState {
  checkedAnswers: [ID!]!
  element: LearnElement!
  kind: ElementStateKind!
}

type ClozeTextLearnElement implements LearnElement {
  elementType: ElementTypeV2!
  """The ID of an object"""
  id: ID!
  parts: [ClozeTextPart!]!
  shuffledAnswers: [ClozeAnswer!]!
  title: String!
}

interface ClozeTextPart {
  """The ID of an object"""
  id: ID!
  kind: ClozeTextPartKind!
}

enum ClozeTextPartKind {
  cloze
  text
}

type ClozeTextShowAnswerElementState implements ElementState & ShowAnswerElementState {
  correctAnswers: [ID!]!
  element: LearnElement!
  kind: ElementStateKind!
  lastCheckedAnswers: [ID!]!
}

type CoachFeedback implements Node {
  coach: User
  createdAt: ZonedDateTIme!
  data: CoachingFeedbackData!
  feedbackGiver: User
  """The ID of an object"""
  id: ID!
}

"""A connection to a list of items."""
type CoachFeedbackConnection {
  """A list of edges."""
  edges: [CoachFeedbackEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CoachFeedbackEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: CoachFeedback!
}

type CoachProfile implements Node {
  averageFeedbackScore: Float!
  baseData: BaseData!
  businessData: BusinessData!
  coach: User
  coachAccountId: ID!
  feedbacks(after: String, before: String, first: Int, last: Int): CoachFeedbackConnection!
  """The ID of an object"""
  id: ID!
  profileData: ProfileData!
}

input CoachProfileBaseData {
  address: AddressInput!
  birthDate: LocalDate!
  birthPlace: String!
  gender: Gender!
  nationality: String!
}

"""An edge in a connection."""
type CoachProfileEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: CoachProfile!
}

type CoachProfileWithCoachings {
  coachingOffer: CoachProfile!
  coachings: [CoachingOffer!]!
}

"""A connection to a list of items."""
type CoachProfileWithCoachingsConnection {
  """A list of edges."""
  edges: [CoachProfileWithCoachingsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CoachProfileWithCoachingsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: CoachProfileWithCoachings!
}

type CoachStatement implements Node {
  billingDetails: BillingDetails
  coachAccountId: ID!
  createdAt: ZonedDateTIme!
  creditNoteData: CreditNoteData
  """The ID of an object"""
  id: ID!
  lineItems: [SessionLineItem!]!
}

"""A connection to a list of items."""
type CoachStatementConnection {
  """A list of edges."""
  edges: [CoachStatementEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CoachStatementEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: CoachStatement!
}

"""Data only accessible by the admin"""
type CoachingAdminMutationSchema {
  addHideVisibilityCoachingConfig(input: AddHideVisibilityCoachingConfigInput!): AddHideVisibilityCoachingConfigPayload
  addOnlyAZAVAccountVisibilityCoachingConfig(input: AddOnlyAZAVAccountVisibilityCoachingConfigInput!): AddOnlyAZAVAccountVisibilityCoachingConfigPayload
  addOnlyBusinessAccountVisibilityCoachingConfig(input: AddOnlyBusinessAccountVisibilityCoachingConfigInput!): AddOnlyBusinessAccountVisibilityCoachingConfigPayload
  addOnlyWithLicenseVisibilityCoachingConfig(input: AddOnlyWithLicenseVisibilityCoachingConfigInput!): AddOnlyWithLicenseVisibilityCoachingConfigPayload
  addParticipant(input: AddParticipantAdminInput!): AddParticipantAdminPayload
  createAvailability(input: CreateAvailabilityInput!): CreateAvailabilityPayload
  createCoachProfile(input: CreateCoachProfileInput!): CreateCoachProfilePayload
  createCoachingOffer(input: CreateCoachingOfferInput!): CreateCoachingOfferPayload
  deleteAvailability(input: DeleteAvailabilityInput!): DeleteAvailabilityPayload
  deleteCoachProfile(input: DeleteCoachProfileInput!): DeleteCoachProfilePayload
  deleteCoachingOffer(input: DeleteCoachingOfferInput!): DeleteCoachingOfferPayload
  editAssociatedCoaches(input: EditAssociatedCoachesInput!): EditAssociatedCoachesPayload
  editAvailability(input: EditAvailabilityInput!): EditAvailabilityPayload
  editAvailabilitySchedule(input: EditAvailabilityScheduleInput!): EditAvailabilitySchedulePayload
  editBaseData(input: EditBaseDataInput!): EditBaseDataPayload
  editBusinessData(input: EditBusinessDataInput!): EditBusinessDataPayload
  editCoachingOfferParticipationCertificate(input: EditCoachingOfferParticipationCertificateInput!): EditCoachingOfferParticipationCertificatePayload
  editCoachingRemuneration(input: EditRenumerationInput!): EditRenumerationPayload
  editGroupSetting(input: EditOneToOneSettingInput!): EditOneToOneSettingPayload
  editOfferDescription(input: EditOfferDescriptionInput!): EditOfferDescriptionPayload
  editProfileData(input: EditProfileDataInput!): EditProfileDataPayload
  registerParticipationAdmin(input: RegisterParticipationAdminInput!): RegisterParticipationAdminPayload
  removeParticipant(input: RemoveParticipantAdminInput!): RemoveParticipantAdminPayload
  removeVisibilityCoachingConfig(input: RemoveVisibilityCoachingConfigInput!): RemoveVisibilityCoachingConfigPayload
}

"""Data only accessible by the admin"""
type CoachingAdminSchema {
  Availabilities(after: String, before: String, filterByCoachIds: [ID!], filterByMaxDate: LocalDate, filterByMinDate: LocalDate, filterByParticipantIds: [ID!], first: Int, last: Int, onlyBooked: Boolean, onlyFree: Boolean, onlyNeedConfirmation: Boolean): AvailabilityConnection!
  AvailabilitySchedules(after: String, before: String, filterByCoaches: ID, first: Int, last: Int): AvailabilityScheduleConnection!
  CoachFeedbacks(after: String, before: String, first: Int, last: Int): CoachFeedbackConnection!
  CoachProfiles(after: String, before: String, filterByUserId: ID, first: Int, last: Int, userName: String): CoachProfileWithCoachingsConnection!
  CoachStatements(after: String, before: String, filterByAccountId: ID, first: Int, last: Int): CoachStatementConnection!
  CoachingOffers(after: String, before: String, first: Int, last: Int, name: String): CoachingOfferConnection!
  FreeCalendarWeeks(coachUserId: ID): [CalendarWeekAndYear!]!
  GetCoachingOffer(after: String, before: String, first: Int, id: ID!, last: Int): CoachingOffer
}

type CoachingFeedbackData {
  comment: String
  score: Int!
}

type CoachingLicenseDefinitionData implements LicenseDefinitionData {
  coachingInfo: LicenseDefinitionCoachingInfo
  kind: LicenseDefinitionDataKind!
  name: String!
}

input CoachingLicenseDefinitionDataInput {
  coachingId: ID!
  name: String!
}

type CoachingMutations {
  addParticipantToBookingAsCoach(input: AddParticipantToBookingAsCoachInput!): AddParticipantToBookingAsCoachPayload
  addParticipantToMyBooking(input: AddParticipantToMyBookingInput!): AddParticipantToMyBookingPayload
  bookCoaching(input: BookCoachingInput!): BookCoachingPayload
  cancelBookingAsCoach(input: CancelBookingAsCoachInput!): CancelBookingAsCoachPayload
  cancelBookingAsParticipant(input: CancelBookingAsParticipantInput!): CancelBookingAsParticipantPayload
  createMyAvailability(input: CreateMyAvailabilityInput!): CreateMyAvailabilityPayload
  deleteMyAvailability(input: DeleteMyAvailabilityInput!): DeleteMyAvailabilityPayload
  editMyAvailability(input: EditMyAvailabilityInput!): EditMyAvailabilityPayload
  editMyAvailabilitySchedule(input: EditMyAvailabilityScheduleInput!): EditMyAvailabilitySchedulePayload
  editMyBaseData(input: EditMyBaseDataInput!): EditMyBaseDataPayload
  editMyBusinessData(input: EditMyBusinessDataInput!): EditMyBusinessDataPayload
  editMyProfileData(input: EditMyProfileDataInput!): EditMyProfileDataPayload
  initializeFreeCalendarWeekOverride(input: InitializeFreeCalendarWeekOverrideInput!): InitializeFreeCalendarWeekOverridePayload
  leaveFeedback(input: LeaveFeedbackInput!): LeaveFeedbackPayload
  registerParticipation(input: RegisterParticipationInput!): RegisterParticipationPayload
  removeParticipantFromBookingAsCoach(input: RemoveParticipantFromBookingAsCoachInput!): RemoveParticipantFromBookingAsCoachPayload
  removeParticipantFromMyBooking(input: RemoveParticipantFromMyBookingInput!): RemoveParticipantFromMyBookingPayload
}

type CoachingOffer implements Node {
  associatedCoaches: [CoachProfile!]!
  cartClickout: CartClickout
  description: CoachingOfferDescription
  """The ID of an object"""
  id: ID!
  licenseAvailability: LicenseAvailability!
  participationCertificate: ParticipationCertificate
  remunerationData: CoachingOfferRemunerationData!
  setting: CoachingSetting!
  visibilityConfigs: [VisibilityCoachingConfig!]!
}

"""A connection to a list of items."""
type CoachingOfferConnection {
  """A list of edges."""
  edges: [CoachingOfferEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type CoachingOfferDescription {
  contents: String
  contractPartner: ContractPartner
  description: String
  image: File
  modules: String
  name: String!
  product: Product
  shortDescription: String
  tags: [AcademiesTag!]!
}

input CoachingOfferDescriptionInput {
  contents: String
  contractPartnerId: ID
  description: String
  imageId: ID
  licenseProductId: ID
  modules: String
  name: String!
  shortDescription: String
  tagIds: [ID!]!
}

"""An edge in a connection."""
type CoachingOfferEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: CoachingOffer!
}

input CoachingOfferParticipationCertificateInput {
  html: String!
  name: String!
  variables: [String!]!
}

interface CoachingOfferRemunerationData {
  kind: CoachingOfferRemunerationDataKind!
  percentageShare: Int!
}

enum CoachingOfferRemunerationDataKind {
  NotRemunerated
  PerSession
}

type CoachingOfferRemunerationDataNotRemunerated implements CoachingOfferRemunerationData {
  kind: CoachingOfferRemunerationDataKind!
  percentageShare: Int!
}

type CoachingOfferRemunerationDataPerSession implements CoachingOfferRemunerationData {
  additionalInformation: String
  kind: CoachingOfferRemunerationDataKind!
  percentageShare: Int!
  sessionRate: Price!
}

type CoachingQueries {
  CoachAvailabilities(after: String, before: String, filterByMaxDate: LocalDate, filterByMinDate: LocalDate, first: Int, last: Int, onlyBooked: Boolean, onlyFree: Boolean, onlyNeedConfirmation: Boolean): AvailabilityConnection!
  CoachingOffersToCoach(after: String, before: String, coachProfileId: ID!, first: Int, last: Int): CoachingOfferConnection!
  FreeAvailabilities(after: String, before: String, filterByCoach: ID, filterByMaxDate: LocalDate, filterByMinDate: LocalDate, first: Int, last: Int): AvailabilityConnection!
}

interface CoachingSetting {
  kind: CoachingSettingKind!
}

enum CoachingSettingKind {
  Group
  OneToOne
}

"""Data partaining to the current user"""
type CoachingViewerSchema {
  CoachCoachingAppointments(after: String, before: String, filterByMaxDate: LocalDate, filterByMinDate: LocalDate, first: Int, last: Int): AvailabilityConnection!
  CoachingOffers(after: String, before: String, first: Int, last: Int): CoachingOfferConnection!
  FreeCalendarWeeks: [CalendarWeekAndYear!]!
  MyAvailabilitySchedule: AvailabilitySchedule
  MyCoachProfile: CoachProfile
  MyCoachingAppointments(after: String, before: String, filterByMaxDate: LocalDate, filterByMinDate: LocalDate, first: Int, last: Int): AvailabilityConnection!
  MyDocuments: [File!]!
}

enum CompanyType {
  Ag
  Einzelunternehmen
  Ev
  Gbr
  Gmbh
  GmbhCoKg
  Kg
  OeffentlicheEinrichtung
  Ohg
  PartmbH
  Ug
  Unknown
}

enum CompanyTypeInput {
  Ag
  Einzelunternehmen
  Ev
  Gbr
  Gmbh
  GmbhCoKg
  Kg
  OeffentlicheEinrichtung
  Ohg
  PartmbH
  Ug
  Unknown
}

input ConstellationCreateBranchRootInput {
  clientMutationId: String
  title: String!
}

type ConstellationCreateBranchRootPayload {
  clientMutationId: String
  edge: UnpublishedLearnablesEdge!
}

type ConstellationLoginResultExtension implements LoginResultExtension {
  doNotUse: String!
  forwardToFrontendURL: String
  isAVGSClient: Boolean!
}

type ConstellationRootExtensionExtension implements RootExtensionExtension {
  contractPartner: ContractPartner
  doNotUse: String!
  isMicroLearning: Boolean!
}

interface ContentExtension {
  doNotUse: String!
}

type ContentExtensionImpl implements ContentExtension {
  doNotUse: String!
}

enum ContentKind {
  Async
  ELearning
}

interface ContentNodeAdvancementResult {
  status: ContentNodeAdvancementStatus!
}

enum ContentNodeAdvancementStatus {
  BlockedByTree
  CanBeRestartedAfterFailed
  CanBeRestartedAfterPassed
  CanBeStarted
  CanNotBeRestartedAfterFailed
  CanNotBeRestartedAfterPassed
  CanNotBeStarted
  Continue
  NotContentNode
  ViolatesTreeFlow
}

type ContentSubmission implements Node {
  definition: ContentSubmissionDefinition!
  """The ID of an object"""
  id: ID!
  lastUpdated: ZonedDateTIme
  learnOpportunity: LearnOpportunityV2
  startedAt: ZonedDateTIme!
}

interface ContentSubmissionDefinition {
  contentKind: ContentKind!
  status: ContentSubmissionStatus!
}

enum ContentSubmissionStatus {
  active
  failed
  passed
}

"""A connection to a list of items."""
type ContentSubmissionsConnection {
  """A list of edges."""
  edges: [ContentSubmissionsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ContentSubmissionsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: ContentSubmission!
}

interface ContentTypeDefinition {
  contentKind: ContentKind!
  continueConfig: ContinueContentConfig!
  definitionType: TypeDefinitionType!
  extension: ContentExtension!
  passConfig: PassContentConfig!
  restartIfFailedConfigs: [RestartIfFailedContentConfig!]!
  restartIfPassedConfig: RestartIfPassedContentConfig!
  rewardConfig: RewardContentConfig!
  rewards: [Reward!]!
  startConfigs: [StartContentConfig!]!
  trigger: TriggerAction_Trigger
}

interface ContinueContentConfig {
  configType: ContinueContentConfigType!
  """The ID of an object"""
  id: ID!
}

enum ContinueContentConfigType {
  ContinueContent_AlwaysRestart
}

type ContinueContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  activeContentSubmissionId: ID!
  status: ContentNodeAdvancementStatus!
}

type ContractPartner implements Node {
  data: ContractPartnerData!
  """The ID of an object"""
  id: ID!
  shareAmountPercentage: Int!
  stripeConnectAccountId: String
}

type ContractPartnerData {
  association: String
  city: String
  country: String
  email: String!
  houseNumber: String
  linkToAGB: String
  name: String!
  postalCode: String
  street: String
  taxNumber: String
}

input ContractPartnerDataInput {
  association: String!
  city: String!
  country: String!
  email: String!
  houseNumber: String!
  linkToAGB: String
  name: String!
  postalCode: String!
  street: String!
  taxNumber: String!
}

"""A connection to a list of items."""
type ContractPartnersConnection {
  """A list of edges."""
  edges: [ContractPartnersEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ContractPartnersEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: ContractPartner!
}

type CoordinatesV2 {
  parentRef: ID
}

enum CountryCode {
  AT
  CH
  DE
}

type CreatableInvoiceData implements InvoiceData {
  kind: InvoiceDataKind!
}

input CreateAVGSPotentialAnalysisLicenseDefinitionInput {
  clientMutationId: String
  data: AVGSPotentialAnalysisLicenseDefinitionDataInput!
}

type CreateAVGSPotentialAnalysisLicenseDefinitionPayload {
  clientMutationId: String
  edge: LicenseDefinitionsEdge!
}

input CreateAccountGroupAssignmentRuleInput {
  active: Boolean!
  clientMutationId: String
  licenseGroupingId: ID!
  name: String!
  userInAccountGroupIds: [ID!]!
}

type CreateAccountGroupAssignmentRulePayload {
  assignmentRule: AssignmentRule!
  clientMutationId: String
}

input CreateAccountGroupProductInput {
  clientMutationId: String
  title: String!
}

type CreateAccountGroupProductPayload {
  clientMutationId: String
  edge: ProductsEdge!
}

input CreateAccountInput {
  clientMutationId: String
  name: String!
}

type CreateAccountPayload {
  clientMutationId: String
  edge: AccountEdge!
}

input CreateActionResultToNextActionsInput {
  actionId: ID!
  actionResultKind: TriggerAction_ActionResultKind!
  clientMutationId: String
}

type CreateActionResultToNextActionsPayload {
  clientMutationId: String
  someActionResultToNextActions: TriggerAction_SomeActionResultToNextActions!
}

input CreateAndAppendChildTagInput {
  clientMutationId: String
  data: TagDataInput!
  parentId: ID!
}

type CreateAndAppendChildTagPayload {
  clientMutationId: String
  edge: AcademiesChildTagsEdge!
}

input CreateAvailabilityInput {
  availabilityData: AvailabilityDataInput!
  clientMutationId: String
  coachAccountRef: ID!
  coachRef: ID!
}

type CreateAvailabilityPayload {
  clientMutationId: String
  edge: AvailabilityEdge!
}

input CreateBranchChildInput {
  clientMutationId: String
  parentBranchId: ID!
  title: String!
}

type CreateBranchChildPayload {
  clientMutationId: String
  createdChildNode: TreeNode!
  tree: Tree!
}

input CreateBranchRootInput {
  clientMutationId: String
  title: String!
}

type CreateBranchRootPayload {
  clientMutationId: String
  createdRootNode: TreeNodesEdge!
  tree: Tree!
}

input CreateClickOutByLinkIdInput {
  clientMutationId: String
  linkId: String!
}

type CreateClickOutByLinkIdPayload {
  clientMutationId: String
  placementUrl: String!
}

input CreateClickOutForUserOrBusinessInput {
  clientMutationId: String
}

type CreateClickOutForUserOrBusinessPayload {
  clientMutationId: String
  placementUrl: String!
}

input CreateClozeTextElementV2Input {
  additionalWords: [String!]!
  clientMutationId: String
  eLearningContentNodeId: ID!
  text: String!
  title: String!
}

type CreateClozeTextElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
}

input CreateCoachProfileInput {
  accountId: ID!
  baseData: CoachProfileBaseData!
  clientMutationId: String
  userId: ID!
}

type CreateCoachProfilePayload {
  clientMutationId: String
  edge: CoachProfileEdge!
}

input CreateCoachStatementsFromUnbilledInput {
  clientMutationId: String
}

type CreateCoachStatementsFromUnbilledPayload {
  clientMutationId: String
}

input CreateCoachingLicenseDefinitionInput {
  clientMutationId: String
  data: CoachingLicenseDefinitionDataInput!
}

type CreateCoachingLicenseDefinitionPayload {
  clientMutationId: String
  edge: LicenseDefinitionsEdge!
}

input CreateCoachingOfferInput {
  clientMutationId: String
  kind: CoachingSettingKind!
}

type CreateCoachingOfferPayload {
  clientMutationId: String
  edge: UnpublishedLearnablesEdge!
}

input CreateContentChildInput {
  clientMutationId: String
  contentKind: String!
  parentBranchId: ID!
  title: String!
}

type CreateContentChildPayload {
  clientMutationId: String
  createdChildNode: TreeNode!
  tree: Tree!
}

input CreateContentRootNodeInput {
  clientMutationId: String
  contentKind: String!
  title: String!
}

type CreateContentRootNodePayload {
  clientMutationId: String
  createdRootNode: TreeNodesEdge!
  tree: Tree!
}

input CreateContractPartnerInput {
  clientMutationId: String
  data: ContractPartnerDataInput!
  shareAmountPercentage: Int!
}

type CreateContractPartnerPayload {
  clientMutationId: String
  edge: ContractPartnersEdge!
}

input CreateCustomerFeedbackInput {
  clientMutationId: String
  feedback: String!
  name: String!
  position: String!
}

type CreateCustomerFeedbackPayload {
  clientMutationId: String
  edge: CustomerFeedbackEdge!
}

input CreateDiscountCodeInput {
  clientMutationId: String
  code: String!
  discountActionId: ID!
}

type CreateDiscountCodePayload {
  clientMutationId: String
  edges: [DiscountCodesV2Edge!]!
}

input CreateDynamicVocabElementInput {
  clientMutationId: String
  eLearningContentNodeId: ID!
  title: String!
}

type CreateDynamicVocabElementPayload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
}

input CreateEnhancedTextElementInput {
  clientMutationId: String
  eLearningContentNodeId: ID!
  readMore: String
  readMoreButtonText: String
  text: String!
  title: String!
}

type CreateEnhancedTextElementPayload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
}

input CreateEuroDiscountActionInput {
  clientMutationId: String
  title: String!
}

type CreateEuroDiscountActionPayload {
  clientMutationId: String
  edge: DiscountActionsEdge!
}

input CreateExternalLicenseInput {
  clientMutationId: String
  data: ExternalLicenseDataInput!
  poolId: ID!
}

type CreateExternalLicensePayload {
  clientMutationId: String
  edge: ExternalLicensesEdge!
}

input CreateExternalLicensePoolInput {
  clientMutationId: String
  data: ExternalLicensePoolDataInput!
}

type CreateExternalLicensePoolPayload {
  clientMutationId: String
  edge: ExternalLicensePoolsEdge!
}

input CreateFileElementV2Input {
  clientMutationId: String
  eLearningContentNodeId: ID!
  fileId: ID
  title: String!
}

type CreateFileElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
}

input CreateGlobalVocabElementInput {
  clientMutationId: String
  eLearningContentNodeId: ID!
  title: String!
}

type CreateGlobalVocabElementPayload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
}

input CreateInstructorImplInput {
  clientMutationId: String
  data: InstructorImplInput!
}

type CreateInstructorImplPayload {
  clientMutationId: String
  data: InstructorImplsEdge!
}

input CreateLicenseProductInput {
  clientMutationId: String
  title: String!
}

type CreateLicenseProductPayload {
  clientMutationId: String
  edge: ProductsEdge!
}

input CreateLicenseUsageReportInput {
  clientMutationId: String
}

type CreateLicenseUsageReportPayload {
  clientMutationId: String
}

input CreateLicensesInput {
  accountId: ID!
  amount: Int!
  clientMutationId: String
  licenseDefinitionId: ID!
}

type CreateLicensesPayload {
  clientMutationId: String
  edges: [LicenseEdge!]!
}

input CreateLimitedCartDiscountInput {
  clientMutationId: String
}

type CreateLimitedCartDiscountPayload {
  clientMutationId: String
  edge: LimitedCartDiscountEdge!
}

input CreateMarkMistakesElementInput {
  clientMutationId: String
  eLearningContentId: ID!
  text: String!
  title: String!
}

type CreateMarkMistakesElementPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
}

input CreateMatrixElementInput {
  clientMutationId: String
  correctAnswer: String!
  eLearningContentId: ID!
  firstColumnTitle: String!
  firstRowTitle: String!
  title: String!
}

type CreateMatrixElementPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
}

input CreateMicroLearningLicenseDefinitionInput {
  clientMutationId: String
  data: MicroLearningLicenseDefinitionDataInput!
}

type CreateMicroLearningLicenseDefinitionPayload {
  clientMutationId: String
  edge: LicenseDefinitionsEdge!
}

input CreateMultipleChoiceElementV2Input {
  answerOptions: [AnswerOptionV2Input!]!
  answeringType: String!
  answeringTypeText: String
  clientMutationId: String
  eLearningContentNodeId: ID!
  imageId: ID
  question: String!
  title: String!
}

type CreateMultipleChoiceElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
}

input CreateMyAvailabilityInput {
  availabilityData: AvailabilityDataInput!
  clientMutationId: String
}

type CreateMyAvailabilityPayload {
  clientMutationId: String
  edge: AvailabilityEdge!
}

input CreateOrderElementInput {
  clientMutationId: String
  eLearningContentNodeId: ID!
  title: String!
}

type CreateOrderElementPayload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
}

input CreateOrderInput {
  cartSelection: CartSelectionInput
  clientMutationId: String
}

type CreateOrderPayload {
  clientMutationId: String
  order: Order!
}

input CreatePercentageDiscountActionInput {
  clientMutationId: String
  title: String!
}

type CreatePercentageDiscountActionPayload {
  clientMutationId: String
  edge: DiscountActionsEdge!
}

input CreatePersonalizedEmailTemplateInput {
  clientMutationId: String
  data: PersonalizedEmailTemplateInput!
}

type CreatePersonalizedEmailTemplatePayload {
  clientMutationId: String
  data: PersonalizedEmailTemplatesEdge!
}

input CreatePersonalizedNotificationTemplateInput {
  clientMutationId: String
  data: PersonalizedNotificationTemplateInput!
}

type CreatePersonalizedNotificationTemplatePayload {
  clientMutationId: String
  data: PersonalizedNotificationTemplatesEdge!
}

input CreatePlacementProductInput {
  clientMutationId: String
  title: String!
}

type CreatePlacementProductPayload {
  clientMutationId: String
  edge: ProductsEdge!
}

input CreatePodcastElementV2Input {
  clientMutationId: String
  eLearningContentNodeId: ID!
  title: String!
}

type CreatePodcastElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
}

input CreatePodcastWithTimestampInput {
  clientMutationId: String
  eLearningContentId: ID!
  podcastFileId: ID
  timestampsWithImage: [TimestampWithImageInput!]!
  title: String!
}

type CreatePodcastWithTimestampPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
}

input CreatePotentialAnalysisClickoutInput {
  clientMutationId: String
  shortTest: Boolean!
}

type CreatePotentialAnalysisClickoutPayload {
  clickout: String!
  clientMutationId: String
}

input CreatePotentialAnalysisInput {
  clientEmail: String!
  clientMutationId: String
  coachAccountId: ID!
  coachId: ID!
  replacementCoachId: ID
  selectedModuleIds: [Int!]!
}

type CreatePotentialAnalysisPayload {
  clientMutationId: String
  edge: PotentialAnalysisEdge!
  info: AVGSPotentialAnalysis_Info!
}

input CreateRandomDiscountCodesInput {
  clientMutationId: String
  discountActionId: ID!
  number: Int!
}

type CreateRandomDiscountCodesPayload {
  clientMutationId: String
  edges: [DiscountCodesV2Edge!]!
}

input CreateReportInput {
  clientMutationId: String
  data: DSAReportDataInput!
}

type CreateReportPayload {
  clientMutationId: String
  referenceNumber: String!
}

input CreateRootTagInput {
  clientMutationId: String
  data: TagDataInput!
}

type CreateRootTagPayload {
  clientMutationId: String
  edge: AcademiesRootTagsEdge!
}

input CreateSingleUserAssignmentRuleInput {
  clientMutationId: String
  licenseGroupingId: ID!
  maxLicenseAmount: Int!
  userId: ID!
}

type CreateSingleUserAssignmentRulePayload {
  assignmentRule: AssignmentRule!
  clientMutationId: String
}

input CreateStripeConnectAccountInput {
  clientMutationId: String
  contractPartnerId: ID!
}

type CreateStripeConnectAccountPayload {
  clientMutationId: String
  contractPartner: ContractPartnersEdge!
}

input CreateTagInput {
  clientMutationId: String
  data: TagInput!
}

type CreateTagPayload {
  clientMutationId: String
  data: TagsEdge!
}

input CreateTextElementV2Input {
  clientMutationId: String
  eLearningContentNodeId: ID!
  text: String!
  title: String!
}

type CreateTextElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
}

input CreateTransfersReportInput {
  clientMutationId: String
  transfersCreatedAfter: ZonedDateTIme!
  transfersCreatedBefore: ZonedDateTIme!
}

type CreateTransfersReportPayload {
  clientMutationId: String
}

input CreateTreeLicenseDefinitionInput {
  clientMutationId: String
  data: TreeLicenseDefinitionDataInput!
}

type CreateTreeLicenseDefinitionPayload {
  clientMutationId: String
  edge: LicenseDefinitionsEdge!
}

input CreateTreeStateForUserInput {
  clientMutationId: String
  rootId: ID!
  userId: ID!
}

type CreateTreeStateForUserPayload {
  clientMutationId: String
  publishedNode: LearnOpportunityV2!
  treeState: TreeState!
}

input CreateTrendInput {
  aboutOffersHeadingAndDescription: HeadingAndDescriptionInput!
  clientMutationId: String
  coachingHeadingAndDescription: HeadingAndDescriptionInput!
  coachingImageId: ID!
  customerData: CustomerDataInput!
  potentialAnalysisHeadingAndDescription: HeadingAndDescriptionInput!
  trendData: TrendDataInput!
  trendMedia: TrendMediaInput!
}

type CreateTrendPayload {
  clientMutationId: String
  edge: TrendEdge!
}

input CreateUploadAsyncElementInput {
  asyncContentId: ID!
  clientMutationId: String
  title: String!
}

type CreateUploadAsyncElementPayload {
  asyncContent: TreeNode!
  clientMutationId: String
}

input CreateUserInAccountGroupAndAddOrInviteUsersMutationInput {
  clientMutationId: String
  emails: [String!]!
  name: String!
}

type CreateUserInAccountGroupAndAddOrInviteUsersMutationPayload {
  clientMutationId: String
  newGroup: UserInAccountGroupWrapperEdge!
}

input CreateUserInAccountInput {
  accountId: ID!
  adsOptIn: Boolean!
  clientMutationId: String
  email: String!
  firstName: String!
  lastName: String!
  password: String!
}

type CreateUserInAccountPayload {
  clientMutationId: String
  userInAccount: UserInAccountEdge!
}

input CreateVideoElementV2Input {
  clientMutationId: String
  eLearningContentNodeId: ID!
  title: String!
  vimeoId: String!
  vimeoVideoSourceId: ID!
}

type CreateVideoElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
}

input CreateVimeoVideoSourceInput {
  accessToken: String!
  clientMutationId: String
  name: String!
}

type CreateVimeoVideoSourcePayload {
  clientMutationId: String
  edge: Vimeo_VimeoVideoSourceEdge!
}

input CreateWordPackageInput {
  clientMutationId: String
  data: WordPackageDataInput!
}

type CreateWordPackagePayload {
  clientMutationId: String
  edge: WordPackageEdge!
}

type CreatedInvoiceData implements InvoiceData {
  createdAt: ZonedDateTIme!
  invoiceFile: File
  invoiceId: String!
  invoiceNumber: String!
  kind: InvoiceDataKind!
}

type CreditNoteData {
  creditNoteFile: File
  creditNoteId: String!
  creditNoteNumber: String
}

type CreditNoteSentUpdate implements HistoryEventInterface {
  creditNoteId: String!
  creditNoteNumber: String!
  kind: HistoryEventType!
}

type CrmTreeHeadUpdaterReward implements Reward {
  """The ID of an object"""
  id: ID!
  kind: RewardKind!
  superId: ID!
}

type CrmTreeHeadUpdater_ErrorOccurredRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type CrmTreeHeadUpdater_HeadUpdatedRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type CrmTreeHeadUpdater_NotPassedRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type CurrentUser {
  accounts: [Account!]!
  permissionsInAccount: [Permission!]!
  user: User!
}

type CustomerData {
  amountCustomer: String!
  customerFeedbacks: [CustomerFeedback!]!
}

input CustomerDataInput {
  amountCustomer: String!
  customerFeedbackIds: [ID!]!
}

type CustomerFeedback implements Node {
  feedback: String!
  """The ID of an object"""
  id: ID!
  name: String!
  position: String!
}

"""Data only accessible by the admin"""
type CustomerFeedbackAdminMutationSchema {
  createCustomerFeedback(input: CreateCustomerFeedbackInput!): CreateCustomerFeedbackPayload
  deleteCustomerFeedback(input: DeleteCustomerFeedbackInput!): DeleteCustomerFeedbackPayload
  editCustomerFeedback(input: EditCustomerFeedbackInput!): EditCustomerFeedbackPayload
}

"""A connection to a list of items."""
type CustomerFeedbackConnection {
  """A list of edges."""
  edges: [CustomerFeedbackEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CustomerFeedbackEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: CustomerFeedback!
}

type CustomerJourneyQueries {
  CustomerFeedback(after: String, before: String, first: Int, last: Int): CustomerFeedbackConnection!
  Dashboard(after: String, before: String, filterByCompleted: Boolean!, filterByText: String, first: Int, kinds: [LearnableKind!]!, last: Int): Dashboard
  trend(after: String, before: String, first: Int, last: Int): TrendConnection!
}

enum CustomerType {
  Business
  Private
}

type DSAReport implements Node {
  createdAt: ZonedDateTIme!
  data: DSAReportData!
  """The ID of an object"""
  id: ID!
  referenceNumber: String!
}

"""A connection to a list of items."""
type DSAReportConnection {
  """A list of edges."""
  edges: [DSAReportEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type DSAReportData {
  email: String
  extra: String
  firstName: String
  lastName: String
  problemType: DSAReportProblemType!
  reportType: DSAReportType!
  url: String
}

input DSAReportDataInput {
  email: String
  extra: String
  firstName: String
  lastName: String
  problemType: DSAReportProblemType!
  reportType: DSAReportType!
  url: String
}

"""An edge in a connection."""
type DSAReportEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: DSAReport!
}

enum DSAReportProblemType {
  Accessibility
  ConsumerProtection
  Disinformation
  IllegalContents
  Other
  PrivacyRequest
  ProtectionOfMinors
  TransparencyForOnlineAds
  UserRightsAndComplaints
}

enum DSAReportType {
  Complaint
  Feedback
  Other
  Report
}

type Dashboard {
  mostRecentLearnable: LearnableWithLastUpdated
  sortedLearnables(after: String, before: String, first: Int, last: Int): SortedLearnablesConnection!
  userData: User
}

type DayAndTimesForCalendarWeek {
  calendarWeek: Int!
  calendarYear: Int!
  dayOfWeek: DayOfWeek!
  timeSlots: [LocalTime!]!
}

input DayAndTimesForCalendarWeekInput {
  calendarWeek: Int!
  calendarYear: Int!
  dayOfWeek: DayOfWeek!
  timeSlots: [LocalTime!]!
}

input DayAndTimesInput {
  dayOfWeek: DayOfWeek!
  timeSlots: [LocalTime!]!
}

scalar DayOfWeek

type DefaultFileAttachment implements AttachmentV2 & FileAttachment {
  description: String
  file: File
  """The ID of an object"""
  id: ID!
  kind: AttachmentKind!
  title: String
}

type DefaultPaymentProviderData implements PaymentProviderData {
  dataType: PaymentProviderDataType!
  paymentMethod: PaymentMethodType!
}

input DeleteActionInput {
  actionId: ID!
  clientMutationId: String
}

type DeleteActionPayload {
  clientMutationId: String
  """The ID of an object"""
  id: ID!
}

input DeleteActionResultToNextActionsInput {
  actionResultToNextActionsId: ID!
  clientMutationId: String
}

type DeleteActionResultToNextActionsPayload {
  clientMutationId: String
  noneActionResultToNextActions: TriggerAction_NoneActionResultToNextActions!
}

input DeleteAssignmentRuleInput {
  assignmentRuleId: ID!
  clientMutationId: String
}

type DeleteAssignmentRulePayload {
  clientMutationId: String
}

input DeleteAvailabilityInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteAvailabilityPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteCoachProfileInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteCoachProfilePayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteCoachingOfferInput {
  clientMutationId: String
  coachingId: ID!
}

type DeleteCoachingOfferPayload {
  clientMutationId: String
  deletedUnpublishedLearnableId: ID!
}

input DeleteConditionInput {
  clientMutationId: String
  conditionId: ID!
  limitedCartDiscountId: ID!
}

type DeleteConditionPayload {
  clientMutationId: String
  limitedCartDiscount: LimitedCartDiscount!
}

input DeleteContractPartnerInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteContractPartnerPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteCourseOrMicroLearningLearnableInput {
  clientMutationId: String
  rootId: ID!
}

type DeleteCourseOrMicroLearningLearnablePayload {
  clientMutationId: String
  deletedCourseOrMicroLearningLearnableId: ID!
}

input DeleteCustomerFeedbackInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteCustomerFeedbackPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteDiscountActionInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteDiscountActionPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteDiscountCodeInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteDiscountCodePayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteElementV2Input {
  clientMutationId: String
  elementId: ID!
}

type DeleteElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
}

input DeleteExternalLicenseInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteExternalLicensePayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteExternalLicensePoolInput {
  clientMutationId: String
  id: ID!
}

type DeleteExternalLicensePoolPayload {
  clientMutationId: String
  """The ID of an object"""
  id: ID!
}

input DeleteFileInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteFilePayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteInstructorImplInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteInstructorImplPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteInvitationInput {
  clientMutationId: String
  id: ID!
}

type DeleteInvitationPayload {
  clientMutationId: String
  deletedId: ID
}

input DeleteLicenseDefinitionInput {
  clientMutationId: String
  licenseDefinitionId: ID!
}

type DeleteLicenseDefinitionPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteLicenseInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteLicensePayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteLimitedCartDiscountInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteLimitedCartDiscountPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteMyAvailabilityInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteMyAvailabilityPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeletePersonalizedEmailTemplateInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeletePersonalizedEmailTemplatePayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeletePersonalizedNotificationTemplateInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeletePersonalizedNotificationTemplatePayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteProductInput {
  clientMutationId: String
  productId: ID!
}

type DeleteProductPayload {
  clientMutationId: String
  productId: ID!
}

input DeleteRewardInput {
  clientMutationId: String
  contentNodeId: ID!
  rewardId: ID!
}

type DeleteRewardPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input DeleteTagInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteTagPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteTreeInput {
  clientMutationId: String
  rootId: ID!
}

type DeleteTreePayload {
  clientMutationId: String
  deletedRootId: ID!
}

input DeleteTrendInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteTrendPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteUserInAccountGroupsInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteUserInAccountGroupsPayload {
  clientMutationId: String
  removedIds: [ID!]!
}

input DeleteUserInput {
  clientMutationId: String
  userId: ID!
}

type DeleteUserPayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteVimeoVideoSourceInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteVimeoVideoSourcePayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

input DeleteWordInput {
  clientMutationId: String
  wordId: ID!
  wordPackageId: ID!
}

input DeleteWordPackageInput {
  clientMutationId: String
  ids: [ID!]!
}

type DeleteWordPackagePayload {
  clientMutationId: String
  deletedIds: [ID!]!
}

type DeleteWordPayload {
  clientMutationId: String
  wordPackage: WordPackage!
}

type DirectFeedbackFlowELearningContentConfig implements FlowELearningContentConfig {
  configType: FlowELearningContentConfigType!
  """The ID of an object"""
  id: ID!
  minNumTriesTillShowAnswer: Int!
}

"""a discount action is a common wrapper of 0 - n discount codes."""
type DiscountAction implements Node {
  calcType: DiscountActionCalcType!
  createdAt: ZonedDateTIme!
  discountCodes(after: String, before: String, first: Int, last: Int): DiscountCodesV2Connection!
  discountCodesCSV: String!
  discountType: DiscountType!
  """The ID of an object"""
  id: ID!
  numUsages: Int!
  title: String!
  usageLimitation: DiscountActionUsageLimitation!
  validUntil: DiscountActionValidUntil!
}

interface DiscountActionAmountLimitation {
  kind: DiscountActionAmountLimitationKind!
}

enum DiscountActionAmountLimitationKind {
  limited
  unlimited
}

type DiscountActionAmountLimited implements DiscountActionAmountLimitation {
  kind: DiscountActionAmountLimitationKind!
  max: Int!
}

type DiscountActionAmountUnlimited implements DiscountActionAmountLimitation {
  kind: DiscountActionAmountLimitationKind!
}

interface DiscountActionCalcType {
  kind: DiscountActionCalcTypeKind!
}

enum DiscountActionCalcTypeKind {
  euro
  percentage
}

type DiscountActionEuroCalcType implements DiscountActionCalcType {
  euro: BigDecimal!
  kind: DiscountActionCalcTypeKind!
}

type DiscountActionPercentageCalcType implements DiscountActionCalcType {
  kind: DiscountActionCalcTypeKind!
  percentage: BigDecimal!
}

interface DiscountActionUsageLimitation {
  kind: DiscountActionUsageLimitationKind!
}

enum DiscountActionUsageLimitationKind {
  limited
  unlimited
}

type DiscountActionUsageLimited implements DiscountActionUsageLimitation {
  kind: DiscountActionUsageLimitationKind!
  maxAmountOfUsages: DiscountActionAmountLimitation!
  maxAmountOfUsagesPerAccount: DiscountActionAmountLimitation!
  onlyForAccountIds: [ID!]!
  onlyForProductIds: [ID!]!
}

type DiscountActionUsageUnlimited implements DiscountActionUsageLimitation {
  kind: DiscountActionUsageLimitationKind!
}

interface DiscountActionValidUntil {
  kind: DiscountActionValidUntilKind!
}

type DiscountActionValidUntilDateTime implements DiscountActionValidUntil {
  dateTime: ZonedDateTIme!
  kind: DiscountActionValidUntilKind!
}

type DiscountActionValidUntilForever implements DiscountActionValidUntil {
  kind: DiscountActionValidUntilKind!
}

enum DiscountActionValidUntilKind {
  untilDateTime
  untilForever
}

"""A connection to a list of items."""
type DiscountActionsConnection {
  """A list of edges."""
  edges: [DiscountActionsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type DiscountActionsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: DiscountAction!
}

"""a discount code."""
type DiscountCode implements Node {
  code: String!
  createdAt: ZonedDateTIme!
  """The ID of an object"""
  id: ID!
  numUsages: Int!
  searchUsages(after: String, before: String, filterByUsedAtFrom: ZonedDateTIme, filterByUsedToFrom: ZonedDateTIme, first: Int, last: Int): SearchDiscountCodeUsagesResult!
}

type DiscountCodeUsage implements Node {
  at: ZonedDateTIme!
  """The ID of an object"""
  id: ID!
  order: Order
}

"""A connection to a list of items."""
type DiscountCodeUsagesConnection {
  """A list of edges."""
  edges: [DiscountCodeUsagesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type DiscountCodeUsagesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: DiscountCodeUsage!
}

"""A connection to a list of items."""
type DiscountCodesV2Connection {
  """A list of edges."""
  edges: [DiscountCodesV2Edge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type DiscountCodesV2Edge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: DiscountCode!
}

interface DiscountType {
  kind: DiscountTypeKind!
}

enum DiscountTypeKind {
  system
  user
}

enum DiscountTypeKindInput {
  system
  user
}

type DisplayMatrixElementCell implements MatrixElementCell {
  content: String!
  """The ID of an object"""
  id: ID!
  kind: MatrixElementCellKind!
  xIdx: Int!
  yIdx: Int!
}

type DisplayMatrixLearnElementCell implements MatrixLearnElementCell {
  content: String!
  kind: MatrixElementCellKind!
  xIdx: Int!
  yIdx: Int!
}

type DoNotRewardTreeConfig implements RewardTreeConfig {
  configType: RewardTreeConfigType!
  """The ID of an object"""
  id: ID!
}

type DoNotShowAnswerTreeConfig implements ShowAnswerTreeConfig {
  configType: ShowAnswerTreeConfigType!
  """The ID of an object"""
  id: ID!
}

type DoRewardContentConfig implements RewardContentConfig {
  configType: RewardContentConfigType!
  """The ID of an object"""
  id: ID!
}

type DynamicVocabElement implements ElementV2 {
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  numDecoy: Int!
  numWords: DynamicVocabElementNumWords!
  packageSelections: [VocabTrainWordPackageSelection!]!
  title: String!
}

interface DynamicVocabElementNumWords {
  kind: DynamicVocabElementNumWordsKind!
}

type DynamicVocabElementNumWordsAll implements DynamicVocabElementNumWords {
  kind: DynamicVocabElementNumWordsKind!
}

enum DynamicVocabElementNumWordsKind {
  All
  Num
}

interface ELearningContentSubmissionDefinition {
  contentKind: ContentKind!
  progress: ELearningContentSubmissionProgress!
  relativeProgress: ELearningContentSubmissionRelativeProgress!
  status: ContentSubmissionStatus!
}

interface ELearningContentSubmissionProgress {
  percentage: Int!
}

type ELearningContentSubmissionRelativeProgress {
  numCorrect: Int!
  numElements: Int!
  percentageCorrect: Int!
}

type ELearningContentTypeDefinition implements ContentTypeDefinition & TypeDefinition {
  contentKind: ContentKind!
  continueConfig: ContinueContentConfig!
  definitionType: TypeDefinitionType!
  elements: [ElementV2!]!
  extension: ContentExtension!
  flowConfig: FlowELearningContentConfig!
  passConfig: PassContentConfig!
  restartIfFailedConfigs: [RestartIfFailedContentConfig!]!
  restartIfPassedConfig: RestartIfPassedContentConfig!
  rewardConfig: RewardContentConfig!
  rewards: [Reward!]!
  startConfigs: [StartContentConfig!]!
  trigger: TriggerAction_Trigger
}

type ELearningMutations {
  canShowElementAnswer(input: CanShowElementAnswerInput!): CanShowElementAnswerPayload
  canSubmitElement(input: CanSubmitElementInput!): CanSubmitElementPayload
  goToNextElement(input: GoToNextElementInput!): GoToNextElementPayload
  goToPreviousElement(input: GoToPreviousElementInput!): GoToPreviousElementPayload
  showElementAnswerElement(input: ShowElementAnswerElementInput!): ShowElementAnswerElementPayload
}

input EditAVGSPotentialAnalysisLicenseDefinitionAdminMutationInput {
  clientMutationId: String
  data: AVGSPotentialAnalysisLicenseDefinitionDataInput!
  licenseDefinitionId: ID!
}

type EditAVGSPotentialAnalysisLicenseDefinitionAdminMutationPayload {
  clientMutationId: String
  licenseDefinition: LicenseDefinition!
}

input EditAcademiesProductExtensionInput {
  clientMutationId: String
  costUnit: String
  productId: ID!
}

type EditAcademiesProductExtensionPayload {
  clientMutationId: String
  product: Product!
}

input EditAccountGroupAssignmentRuleInput {
  active: Boolean!
  assignmentRuleId: ID!
  clientMutationId: String
  name: String!
  userInAccountGroupIds: [ID!]!
}

type EditAccountGroupAssignmentRulePayload {
  assignmentRule: AssignmentRule!
  clientMutationId: String
}

input EditAccountGroupProductInput {
  accountGroupId: ID!
  clientMutationId: String
  id: ID!
}

type EditAccountGroupProductPayload {
  clientMutationId: String
  product: Product!
}

input EditAfterDateTimeVisibilityTreeConfigInput {
  clientMutationId: String
  configId: ID!
  newDateTime: ZonedDateTIme!
  rootNodeId: ID!
}

type EditAfterDateTimeVisibilityTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input EditAssociatedCoachesInput {
  clientMutationId: String
  coachIds: [ID!]!
  id: ID!
  potentialCancellationMessage: String!
}

type EditAssociatedCoachesPayload {
  clientMutationId: String
  coachingOffer: CoachingOffer!
}

input EditAvailabilityInput {
  availabilityData: AvailabilityDataInput!
  availabilityId: ID!
  clientMutationId: String
}

type EditAvailabilityPayload {
  availability: Availability!
  clientMutationId: String
}

input EditAvailabilityScheduleInput {
  clientMutationId: String
  coachAccountId: ID!
  coachId: ID!
  scheduleData: ScheduleDataInput!
}

type EditAvailabilitySchedulePayload {
  clientMutationId: String
  schedule: AvailabilitySchedule!
}

input EditBaseDataInput {
  baseData: CoachProfileBaseData!
  clientMutationId: String
  coachProfileId: ID!
}

type EditBaseDataPayload {
  clientMutationId: String
  edge: CoachProfileEdge!
}

input EditBlockPermanentlyRestartIfFailedContentConfigInput {
  clientMutationId: String
  configId: ID!
  contentNodeId: ID!
  newMaximumTries: Int!
}

type EditBlockPermanentlyRestartIfFailedContentConfigPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input EditBlockTemporarilyRestartIfFailedContentConfigInput {
  clientMutationId: String
  configId: ID!
  contentNodeId: ID!
  newDaysToBlock: Int!
}

type EditBlockTemporarilyRestartIfFailedContentConfigPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input EditBusinessBaseDataAdminInput {
  accountId: ID!
  baseData: BusinessBaseDataInput!
  clientMutationId: String
}

type EditBusinessBaseDataAdminPayload {
  baseData: BusinessBaseData!
  clientMutationId: String
}

input EditBusinessBaseDataInput {
  baseData: BusinessBaseDataInput!
  clientMutationId: String
}

type EditBusinessBaseDataPayload {
  baseData: BusinessBaseData!
  clientMutationId: String
}

input EditBusinessDataInput {
  businessData: BusinessDataInput!
  clientMutationId: String
  coachProfileId: ID!
}

type EditBusinessDataPayload {
  clientMutationId: String
  edge: CoachProfileEdge!
}

input EditClozeTextElementV2Input {
  additionalWords: [String!]!
  clientMutationId: String
  clozeTextElementId: ID!
  text: String!
  title: String!
}

type EditClozeTextElementV2Payload {
  clientMutationId: String
  clozeTextElement: ClozeTextElementV2!
  eLearningContentNode: TreeNode!
}

input EditCoachingLicenseDefinitionAdminMutationInput {
  clientMutationId: String
  data: CoachingLicenseDefinitionDataInput!
  licenseDefinitionId: ID!
}

type EditCoachingLicenseDefinitionAdminMutationPayload {
  clientMutationId: String
  licenseDefinition: LicenseDefinition!
}

input EditCoachingOfferParticipationCertificateInput {
  clientMutationId: String
  coachingOfferId: ID!
  participationCertificateOpt: CoachingOfferParticipationCertificateInput
}

type EditCoachingOfferParticipationCertificatePayload {
  clientMutationId: String
  coachingOffer: CoachingOffer!
}

input EditContractPartnerDataInput {
  clientMutationId: String
  data: ContractPartnerDataInput!
  id: ID!
  shareAmountPercentage: Int!
}

type EditContractPartnerDataPayload {
  clientMutationId: String
  contractPartner: ContractPartner!
}

input EditCustomerFeedbackInput {
  clientMutationId: String
  customerFeedbackId: ID!
  feedback: String!
  name: String!
  position: String!
}

type EditCustomerFeedbackPayload {
  clientMutationId: String
  edge: CustomerFeedbackEdge!
}

input EditDefaultFileAttachmentInput {
  attachmentId: ID!
  clientMutationId: String
  descriptionOpt: String
  fileId: ID!
  nodeId: ID!
  titleOpt: String
}

type EditDefaultFileAttachmentPayload {
  clientMutationId: String
  node: TreeNode!
}

input EditDirectFeedbackFlowELearningContentConfigInput {
  clientMutationId: String
  configId: ID!
  contentId: ID!
  minNumTriesTillShowAnswer: Int!
}

type EditDirectFeedbackFlowELearningContentConfigPayload {
  clientMutationId: String
  content: TreeNode!
}

input EditDiscountCodeInput {
  clientMutationId: String
  discountCodeId: ID!
  newCode: String!
}

type EditDiscountCodePayload {
  clientMutationId: String
  discountCode: DiscountCode!
}

input EditDynamicVocabElementInput {
  clientMutationId: String
  elementId: ID!
  title: String!
  wordPackageIds: [ID!]!
}

type EditDynamicVocabElementPayload {
  clientMutationId: String
  dynamicVocabElement: DynamicVocabElement!
  eLearningContentNode: TreeNode!
}

input EditEducationalParticipationCertificateRewardInput {
  clientMutationId: String
  contentId: ID!
  newData: ParticipationCertificateRewardDataInput!
  rewardId: ID!
}

type EditEducationalParticipationCertificateRewardPayload {
  clientMutationId: String
  content: TreeNode!
}

input EditEnhancedTextElementInput {
  clientMutationId: String
  enhancedTextElementId: ID!
  readMore: String
  readMoreButtonText: String
  text: String!
  title: String!
}

type EditEnhancedTextElementPayload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
  enhancedTextElement: EnhancedTextElement!
}

input EditEuroDiscountActionInput {
  clientMutationId: String
  discountActionId: ID!
  newDiscountType: String!
  newEuro: BigDecimal!
  newTitle: String!
  newUsageLimitation: UpdateUsageLimited
  newValidUntil: ZonedDateTIme
}

type EditEuroDiscountActionPayload {
  clientMutationId: String
  discountAction: DiscountAction!
}

input EditExternalLicenseInput {
  clientMutationId: String
  data: ExternalLicenseDataInput!
  externalLicenseId: ID!
}

type EditExternalLicensePayload {
  clientMutationId: String
  externalLicense: ExternalLicense!
}

input EditExternalLicensePoolInput {
  clientMutationId: String
  data: ExternalLicensePoolDataInput!
  id: ID!
}

type EditExternalLicensePoolPayload {
  clientMutationId: String
  externalLicensePool: ExternalLicensePool!
}

input EditExternalLicenseRewardInput {
  clientMutationId: String
  contentId: ID!
  newData: ExternalLicenseRewardDataInput!
  rewardId: ID!
}

type EditExternalLicenseRewardPayload {
  clientMutationId: String
  content: TreeNode!
}

input EditFeatureToggleDataInput {
  clientMutationId: String
  data: FeatureToggleDataInput!
  id: ID!
}

type EditFeatureToggleDataPayload {
  clientMutationId: String
  featureToggle: FeatureToggle!
}

input EditFileElementV2Input {
  clientMutationId: String
  fileElementId: ID!
  fileId: ID
  title: String!
}

type EditFileElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
  fileElement: FileElementV2!
}

input EditGlobalVocabElementInput {
  clientMutationId: String
  elementId: ID!
  title: String!
}

type EditGlobalVocabElementPayload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
  globalVocabElement: GlobalVocabElement!
}

input EditLicenseModelInput {
  clientMutationId: String
  licenseModelKind: Kind!
}

type EditLicenseModelPayload {
  clientMutationId: String
}

input EditLicenseProductInput {
  clientMutationId: String
  id: ID!
  licenseDefinitionAmount: Int
  licenseDefinitionId: ID!
}

type EditLicenseProductPayload {
  clientMutationId: String
  product: Product!
}

input EditLimitedCartDiscountInput {
  clientMutationId: String
  limitedCartDiscountId: ID!
  percentageValue: Int!
  title: String!
}

type EditLimitedCartDiscountPayload {
  clientMutationId: String
  limitedCartDiscount: LimitedCartDiscount!
}

input EditMarkMistakesElementInput {
  clientMutationId: String
  markMistakesElementId: ID!
  newText: String!
  newTitle: String!
}

type EditMarkMistakesElementPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
  markMistakesElement: MarkMistakesElement!
}

input EditMatrixElementInput {
  clientMutationId: String
  matrixElementId: ID!
  newTitle: String!
}

type EditMatrixElementPayload {
  MatrixElement: MatrixElement!
  clientMutationId: String
  eLearningContent: TreeNode!
}

input EditMicroLearningLicenseDefinitionAdminMutationInput {
  clientMutationId: String
  data: MicroLearningLicenseDefinitionDataInput!
  licenseDefinitionId: ID!
}

type EditMicroLearningLicenseDefinitionAdminMutationPayload {
  clientMutationId: String
  licenseDefinition: LicenseDefinition!
}

input EditMultipleChoiceElementV2Input {
  answerOptions: [AnswerOptionV2Input!]!
  answeringType: String!
  answeringTypeText: String
  clientMutationId: String
  imageIdOpt: ID
  multipleChoiceElementId: ID!
  question: String!
  title: String!
}

type EditMultipleChoiceElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
  multipleChoiceElement: MultipleChoiceElementV2!
}

input EditMyAvailabilityInput {
  availabilityData: AvailabilityDataInput!
  availabilityId: ID!
  clientMutationId: String
}

type EditMyAvailabilityPayload {
  availability: Availability!
  clientMutationId: String
}

input EditMyAvailabilityScheduleInput {
  clientMutationId: String
  scheduleData: ScheduleDataInput!
}

type EditMyAvailabilitySchedulePayload {
  clientMutationId: String
  schedule: AvailabilitySchedule!
}

input EditMyBaseDataInput {
  baseData: CoachProfileBaseData!
  clientMutationId: String
}

type EditMyBaseDataPayload {
  clientMutationId: String
  coachProfile: CoachProfile!
}

input EditMyBusinessDataInput {
  businessData: BusinessDataInput!
  clientMutationId: String
}

type EditMyBusinessDataPayload {
  clientMutationId: String
  coachProfile: CoachProfile!
}

input EditMyProfileDataInput {
  clientMutationId: String
  profileData: ProfileDataInput!
}

type EditMyProfileDataPayload {
  clientMutationId: String
  coachProfile: CoachProfile!
}

input EditNodeCoreInput {
  clientMutationId: String
  description: String
  imageId: ID
  instructorIds: [ID!]!
  nodeId: ID!
  shortDescription: String
  title: String!
}

type EditNodeCorePayload {
  clientMutationId: String
  editedNode: TreeNode!
}

input EditNotAfterDateTimeVisibilityTreeConfigInput {
  clientMutationId: String
  configId: ID!
  newDateTime: ZonedDateTIme!
  rootNodeId: ID!
}

type EditNotAfterDateTimeVisibilityTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input EditOfferDescriptionInput {
  clientMutationId: String
  description: CoachingOfferDescriptionInput!
  id: ID!
}

type EditOfferDescriptionPayload {
  clientMutationId: String
  coachingOffer: CoachingOffer!
}

input EditOneToOneSettingInput {
  clientMutationId: String
  id: ID!
  setting: GroupCoachingSettingInput!
}

type EditOneToOneSettingPayload {
  clientMutationId: String
  coachingOffer: CoachingOffer!
}

input EditOrderElementInput {
  clientMutationId: String
  newAnsweringTypeTextOpt: String
  newTitle: String!
  orderElementId: ID!
}

type EditOrderElementPayload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
  orderElement: OrderElement!
}

input EditOrderItemInput {
  clientMutationId: String
  newText: String!
  orderElementId: ID!
  orderItemId: ID!
}

type EditOrderItemPayload {
  clientMutationId: String
  orderElement: OrderElement!
}

input EditPercentageDiscountActionInput {
  clientMutationId: String
  discountActionId: ID!
  newDiscountType: String!
  newPercentage: BigDecimal!
  newTitle: String!
  newUsageLimitation: UpdateUsageLimited
  newValidUntil: ZonedDateTIme
}

type EditPercentageDiscountActionPayload {
  clientMutationId: String
  discountAction: DiscountAction!
}

input EditPodcastWithTimestampInput {
  clientMutationId: String
  elementId: ID!
  newPodcastFileId: ID!
  newTimestampsWithImage: [TimestampWithImageInput!]!
  newTitle: String!
}

type EditPodcastWithTimestampPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
  podcastWithTimestampElement: PodcastWithTimestamp!
}

input EditPodigeePodcastElementV2Input {
  clientMutationId: String
  lengthInSeconds: Int!
  podigeePodcastElementId: ID!
  podigeeUrl: String!
  title: String!
}

type EditPodigeePodcastElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
  podigeePodcastElement: PodcastElementV2!
}

input EditPrivateBaseDataAdminInput {
  accountId: ID!
  baseData: PrivateBaseDataInput!
  clientMutationId: String
}

type EditPrivateBaseDataAdminPayload {
  baseData: PrivateBaseData!
  clientMutationId: String
}

input EditPrivateBaseDataInput {
  baseData: PrivateBaseDataInput!
  clientMutationId: String
}

type EditPrivateBaseDataPayload {
  baseData: PrivateBaseData!
  clientMutationId: String
}

input EditProductInput {
  clientMutationId: String
  newIsHidden: Boolean!
  newIsTaxFree: Boolean!
  newNetPrice: BigDecimal!
  newTitle: String!
  productId: ID!
}

type EditProductPayload {
  clientMutationId: String
  editedProduct: Product!
}

input EditProductSelectionConditionInput {
  amount: Int!
  clientMutationId: String
  conditionId: ID!
  limitedCartDiscountId: ID!
  productId: ID!
}

type EditProductSelectionConditionPayload {
  clientMutationId: String
  limitedCartDiscount: LimitedCartDiscount!
}

input EditProfileDataInput {
  clientMutationId: String
  coachProfileId: ID!
  profileData: ProfileDataInput!
}

type EditProfileDataPayload {
  clientMutationId: String
  edge: CoachProfileEdge!
}

input EditRenumerationInput {
  additionalInformation: String
  clientMutationId: String
  id: ID!
  percentageShare: Int!
  sessionRate: PriceInput!
}

type EditRenumerationPayload {
  clientMutationId: String
  coachingOffer: CoachingOffer!
}

input EditRootNodePartInput {
  clientMutationId: String
  firstReleasedAt: ZonedDateTIme
  iconId: ID
  rootNodeId: ID!
  searchWords: String
  tagIds: [ID!]!
}

type EditRootNodePartPayload {
  clientMutationId: String
  editedNode: TreeNode!
}

input EditSingleUserAssignmentRuleInput {
  assignmentRuleId: ID!
  clientMutationId: String
  maxLicenseAmount: Int!
  userId: ID!
}

type EditSingleUserAssignmentRulePayload {
  assignmentRule: AssignmentRule!
  clientMutationId: String
}

input EditTextElementV2Input {
  clientMutationId: String
  text: String!
  textElementId: ID!
  title: String!
}

type EditTextElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
  textElement: TextElementV2!
}

input EditTreeLicenseDefinitionAdminMutationInput {
  clientMutationId: String
  data: TreeLicenseDefinitionDataInput!
  licenseDefinitionId: ID!
}

type EditTreeLicenseDefinitionAdminMutationPayload {
  clientMutationId: String
  licenseDefinition: LicenseDefinition!
}

input EditTrendInput {
  aboutOffersHeadingAndDescription: HeadingAndDescriptionInput!
  clientMutationId: String
  coachingHeadingAndDescription: HeadingAndDescriptionInput!
  coachingImageId: ID!
  customerData: CustomerDataInput!
  potentialAnalysisHeadingAndDescription: HeadingAndDescriptionInput!
  trendData: TrendDataInput!
  trendId: ID!
  trendMedia: TrendMediaInput!
}

type EditTrendPayload {
  clientMutationId: String
  edge: TrendEdge!
}

input EditUploadAsyncElementInput {
  assignedEvaluator: ID!
  clientMutationId: String
  id: ID!
  taskDescription: String!
  title: String!
}

type EditUploadAsyncElementPayload {
  asyncContent: TreeNode!
  clientMutationId: String
  uploadAsyncElement: UploadAsyncElement!
}

input EditUserInAccountGroupAndAddOrInviteUsersMutationInput {
  clientMutationId: String
  emails: [String!]!
  id: ID!
  newName: String!
}

type EditUserInAccountGroupAndAddOrInviteUsersMutationPayload {
  clientMutationId: String
  group: UserInAccountGroupWrapper
}

input EditUserInput {
  activated: Boolean!
  adsOptIn: Boolean!
  branch: Branch
  clientMutationId: String
  email: String!
  firstName: String!
  imageId: ID
  lastName: String!
  position: String
  teamSize: TeamSize
  userId: ID!
}

type EditUserPayload {
  clientMutationId: String
  user: User!
}

input EditVideoElementV2Input {
  clientMutationId: String
  title: String!
  videoElementId: ID!
  vimeoId: String!
  vimeoVideoSourceId: ID!
}

type EditVideoElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
  videoElement: VideoElement!
}

input EditVimeoPodcastElementV2Input {
  clientMutationId: String
  title: String!
  vimeoId: String!
  vimeoPodcastElementId: ID!
  vimeoVideoSourceId: ID!
}

type EditVimeoPodcastElementV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
  vimeoPodcastElement: PodcastElementV2!
}

input EditVimeoVideoSourceInput {
  clientMutationId: String
  id: ID!
  name: String!
}

type EditVimeoVideoSourcePayload {
  clientMutationId: String
  edge: Vimeo_VimeoVideoSourceEdge!
}

input EditWordInput {
  clientMutationId: String
  explanation: String!
  translation: String
  word: String!
  wordId: ID!
  wordPackageId: ID!
}

input EditWordPackageInput {
  clientMutationId: String
  data: WordPackageDataInput!
  wordPackageId: ID!
}

type EditWordPackagePayload {
  clientMutationId: String
  wordPackage: WordPackage!
}

input EditWordPackageRewardInput {
  clientMutationId: String
  contentId: ID!
  newData: WordPackageRewardDataInput!
  rewardId: ID!
}

type EditWordPackageRewardPayload {
  clientMutationId: String
  content: TreeNode!
}

type EditWordPayload {
  clientMutationId: String
  wordPackage: WordPackage!
}

input EditWrongAnswerInMatrixElementCellInput {
  clientMutationId: String
  matrixCellId: ID!
  matrixElementId: ID!
  wrongAnswerContent: String!
  wrongAnswerId: ID!
}

type EditWrongAnswerInMatrixElementCellPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
}

"""Data only accessible by the admin"""
type ElearningV2AdminMutationSchema {
  addColumnToMatrixElement(input: AddColumnToMatrixElementInput!): AddColumnToMatrixElementPayload
  addOrderItem(input: AddOrderItemInput!): AddOrderItemPayload
  addRowToMatrixElement(input: AddRowToMatrixElementInput!): AddRowToMatrixElementPayload
  addWrongAnswerInMatrixElementCell(input: AddWrongAnswerInMatrixElementCellInput!): AddWrongAnswerInMatrixElementCellPayload
  createClozeTextElement(input: CreateClozeTextElementV2Input!): CreateClozeTextElementV2Payload
  createDynamicVocabElement(input: CreateDynamicVocabElementInput!): CreateDynamicVocabElementPayload
  createEnhancedTextElement(input: CreateEnhancedTextElementInput!): CreateEnhancedTextElementPayload
  createFileElement(input: CreateFileElementV2Input!): CreateFileElementV2Payload
  createGlobalVocabElement(input: CreateGlobalVocabElementInput!): CreateGlobalVocabElementPayload
  createMarkMistakesElement(input: CreateMarkMistakesElementInput!): CreateMarkMistakesElementPayload
  createMatrixElement(input: CreateMatrixElementInput!): CreateMatrixElementPayload
  createMultipleChoiceElement(input: CreateMultipleChoiceElementV2Input!): CreateMultipleChoiceElementV2Payload
  createOrderElement(input: CreateOrderElementInput!): CreateOrderElementPayload
  createPodcastElement(input: CreatePodcastElementV2Input!): CreatePodcastElementV2Payload
  createPodcastWithTimestampElement(input: CreatePodcastWithTimestampInput!): CreatePodcastWithTimestampPayload
  createTextElement(input: CreateTextElementV2Input!): CreateTextElementV2Payload
  createVideoElement(input: CreateVideoElementV2Input!): CreateVideoElementV2Payload
  deleteElement(input: DeleteElementV2Input!): DeleteElementV2Payload
  editClozeTextElement(input: EditClozeTextElementV2Input!): EditClozeTextElementV2Payload
  editDynamicVocabElement(input: EditDynamicVocabElementInput!): EditDynamicVocabElementPayload
  editEnhancedTextElement(input: EditEnhancedTextElementInput!): EditEnhancedTextElementPayload
  editFileElement(input: EditFileElementV2Input!): EditFileElementV2Payload
  editGlobalVocabElement(input: EditGlobalVocabElementInput!): EditGlobalVocabElementPayload
  editMarkMistakesElement(input: EditMarkMistakesElementInput!): EditMarkMistakesElementPayload
  editMatrixElement(input: EditMatrixElementInput!): EditMatrixElementPayload
  editMultipleChoiceElement(input: EditMultipleChoiceElementV2Input!): EditMultipleChoiceElementV2Payload
  editOrderElement(input: EditOrderElementInput!): EditOrderElementPayload
  editOrderItem(input: EditOrderItemInput!): EditOrderItemPayload
  editPodcastWithTimestampElement(input: EditPodcastWithTimestampInput!): EditPodcastWithTimestampPayload
  editPodigeePodcastElement(input: EditPodigeePodcastElementV2Input!): EditPodigeePodcastElementV2Payload
  editTextElement(input: EditTextElementV2Input!): EditTextElementV2Payload
  editVideoElement(input: EditVideoElementV2Input!): EditVideoElementV2Payload
  editVimeoPodcastElement(input: EditVimeoPodcastElementV2Input!): EditVimeoPodcastElementV2Payload
  editWrongAnswerInMatrixElementCell(input: EditWrongAnswerInMatrixElementCellInput!): EditWrongAnswerInMatrixElementCellPayload
  getVideoData(input: GetVideoDataV2Input!): GetVideoDataV2Payload
  moveOrderItems(input: MoveOrderItemsInput!): MoveOrderItemsPayload
  rearrangeElements(input: RearrangeElementsV2Input!): RearrangeElementsV2Payload
  removeColumnFromMatrixElement(input: RemoveColumnFromMatrixElementInput!): RemoveColumnFromMatrixElementPayload
  removeOrderItem(input: RemoveOrderItemInput!): RemoveOrderItemPayload
  removeRowFromMatrixElement(input: RemoveRowFromMatrixElementInput!): RemoveRowFromMatrixElementPayload
  removeWrongAnswerFromMatrixElementCell(input: RemoveWrongAnswerFromMatrixElementCellInput!): RemoveWrongAnswerFromMatrixElementCellPayload
  setCorrectAnswerInMatrixElementCell(input: SetCorrectAnswerInMatrixElementCellInput!): SetCorrectAnswerInMatrixElementCellPayload
  setMatrixElementColumnTitle(input: SetMatrixElementColumnTitleInput!): SetMatrixElementColumnTitlePayload
  setMatrixElementRowTitle(input: SetMatrixElementRowTitleInput!): SetMatrixElementRowTitlePayload
}

interface ElementExtension {
  doNotUse: String!
}

type ElementExtensionImpl implements ElementExtension {
  doNotUse: String!
  points: Int!
}

interface ElementState {
  element: LearnElement!
  kind: ElementStateKind!
}

enum ElementStateKind {
  Input
  InputAndIsCorrect
  ShowAnswer
  Untouched
  UntouchedAndPreviouslyIncorrect
}

enum ElementTypeV2 {
  clozeText
  dynamicVocab
  enhancedText
  file
  globalVocab
  markMistakes
  matrix
  multipleChoice
  order
  podcast
  podcastWithTimestamp
  text
  video
}

interface ElementV2 {
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  title: String!
}

type ElementsSummary {
  numExerciseElements: Int!
  numFileElements: Int!
  sumPodcastWithTimestampLengthInSec: Int!
  sumTextLengthInSec: Int!
  sumVideoLengthInSec: Int!
}

"""Data only accessible by the admin"""
type EmailAdminMutationSchema {
  createPersonalizedEmailTemplate(input: CreatePersonalizedEmailTemplateInput!): CreatePersonalizedEmailTemplatePayload
  deletePersonalizedEmailTemplate(input: DeletePersonalizedEmailTemplateInput!): DeletePersonalizedEmailTemplatePayload
  sendEmail(input: SendEmailInput!): SendEmailPayload
  updatePersonalizedEmailTemplate(input: UpdatePersonalizedEmailTemplateInput!): UpdatePersonalizedEmailTemplatePayload
}

"""Data only accessible by the admin"""
type EmailAdminSchema {
  AvailableSystemTemplates(after: String, before: String, first: Int, last: Int): [EmailTemplate!]!
  PersonalizedEmailTemplates(after: String, before: String, first: Int, last: Int): PersonalizedEmailTemplatesConnection!
}

type EmailTemplate {
  body: String!
  key: String!
  previewText: String!
  subject: String!
  variables: [String!]!
}

type EmployerInvoicePaymentMethod implements SelectedPaymentMethod {
  paymentMethodId: PaymentMethodType!
  selectedPaymentMethodType: SelectedPaymentMethodType!
}

type EmptyInvoiceData implements InvoiceData {
  kind: InvoiceDataKind!
}

type EmptyOrderExtension implements OrderExtension {
  kind: OrderExtensionKind!
}

type EmptyTreeStateExtension implements TreeStateExtension {
  doNotUse: String!
}

type EnhancedTextElement implements ElementV2 {
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  readMore: String
  readMoreButtonText: String
  text: String!
  title: String!
}

type EnhancedTextLearnElement implements LearnElement {
  elementType: ElementTypeV2!
  """The ID of an object"""
  id: ID!
  readMore: String
  readMoreButtonText: String
  text: String!
  title: String!
}

input EvaluateUploadAsyncElementTaskInput {
  clientMutationId: String
  fileId: ID!
  taskId: ID!
  text: String
}

type EvaluateUploadAsyncElementTaskPayload {
  clientMutationId: String
  evaluatedTask: EvaluatedUploadAsyncElementTask!
}

type EvaluatedUploadAsyncElementTask implements AsyncElementTask & Node & UploadAsyncElementTask {
  assignedEvaluator: User
  elementKind: AsyncElementKind!
  evaluation: UploadEvaluation!
  extension: AsyncElementTaskExtension!
  file: File
  id: ID!
  status: AsyncElementTaskStatus!
  submissionInfo: AsyncElementTaskSubmissionInfo!
}

type ExternalLicense implements Node {
  data: ExternalLicenseData!
  """The ID of an object"""
  id: ID!
  issuingInfo: ExternalLicenseIssuingInfoInterface!
  pool: ExternalLicensePool
}

type ExternalLicenseData {
  code: String!
  name: String!
}

input ExternalLicenseDataInput {
  code: String
  name: String
}

type ExternalLicenseIssuedToUserIssuingInfoType implements ExternalLicenseIssuingInfoInterface {
  hasBeenIssued: Boolean!
  issuedAt: ZonedDateTIme!
  issuedTo: User
  kind: ExternalLicenseIssuingInfoKind!
  validUntil: ZonedDateTIme!
}

interface ExternalLicenseIssuingInfoInterface {
  hasBeenIssued: Boolean!
  kind: ExternalLicenseIssuingInfoKind!
}

enum ExternalLicenseIssuingInfoKind {
  issuedToUser
  notIssued
}

type ExternalLicenseNotIssuedIssuingInfoType implements ExternalLicenseIssuingInfoInterface {
  hasBeenIssued: Boolean!
  kind: ExternalLicenseIssuingInfoKind!
}

type ExternalLicensePool implements Node {
  canBeDeleted: Boolean!
  data: ExternalLicensePoolData!
  """The ID of an object"""
  id: ID!
}

type ExternalLicensePoolData {
  link: String
  name: String!
  usageInformation: String!
  validNumDaysAfterIssuing: Int!
}

input ExternalLicensePoolDataInput {
  link: String
  name: String!
  usageInformation: String!
  validNumDaysAfterIssuing: Int!
}

"""A connection to a list of items."""
type ExternalLicensePoolsConnection {
  """A list of edges."""
  edges: [ExternalLicensePoolsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ExternalLicensePoolsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: ExternalLicensePool!
}

type ExternalLicenseReward implements Reward {
  data: ExternalLicenseRewardData!
  """The ID of an object"""
  id: ID!
  kind: RewardKind!
  superId: ID!
}

type ExternalLicenseRewardData {
  pool: ExternalLicensePool
}

input ExternalLicenseRewardDataInput {
  pool: ID!
}

type ExternalLicense_ErrorOccurredRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type ExternalLicense_IssuedToUserRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type ExternalLicense_NotPassedRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

"""A connection to a list of items."""
type ExternalLicensesConnection {
  """A list of edges."""
  edges: [ExternalLicensesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ExternalLicensesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: ExternalLicense!
}

type FailedELearningContentSubmissionDefinition implements ContentSubmissionDefinition & ELearningContentSubmissionDefinition & FinishedELearningContentSubmissionDefinitionInterface {
  contentKind: ContentKind!
  progress: ELearningContentSubmissionProgress!
  relativeProgress: ELearningContentSubmissionRelativeProgress!
  rewardResults: [RewardResult!]!
  status: ContentSubmissionStatus!
}

enum FeatureId {
  potentialAnalysisV2
  test
}

type FeatureToggle implements Node {
  data: FeatureToggleData!
  """The ID of an object"""
  id: ID!
}

"""Data only accessible by the admin"""
type FeatureToggleAdminMutationSchema {
  editFeatureToggleData(input: EditFeatureToggleDataInput!): EditFeatureToggleDataPayload
}

"""Data only accessible by the admin"""
type FeatureToggleAdminSchema {
  FeatureToggles(after: String, before: String, filterByIsActive: Boolean, filterByName: String, first: Int, last: Int): FeatureTogglesConnection!
}

type FeatureToggleData {
  isActive: Boolean!
  name: String!
}

input FeatureToggleDataInput {
  isActive: Boolean!
  name: String!
}

type FeatureToggleQueries {
  ActiveFeatureToggleIds: [FeatureId!]!
}

"""A connection to a list of items."""
type FeatureTogglesConnection {
  """A list of edges."""
  edges: [FeatureTogglesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type FeatureTogglesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: FeatureToggle!
}

input FeedbackData {
  comment: String
  score: Int!
}

type File implements Node {
  accessType: FileAccessType!
  fileSize: Long!
  fileType: String!
  """The ID of an object"""
  id: ID!
  name: String!
  storageKey: String!
  tags: [String!]!
  thumbnail: String
  thumbnailKey: String
  uploadDateTime: ZonedDateTIme!
  url: String
}

enum FileAccessType {
  public
  signedUrl
}

interface FileAttachment {
  description: String
  file: File
  """The ID of an object"""
  id: ID!
  kind: AttachmentKind!
  title: String
}

enum FileContentTypeV2 {
  jpg
  pdf
  png
}

type FileElementV2 implements ElementV2 {
  elementType: ElementTypeV2!
  extension: ElementExtension!
  file: File
  fileContentType: FileContentTypeV2!
  """The ID of an object"""
  id: ID!
  title: String!
}

type FileLearnElement implements LearnElement {
  elementType: ElementTypeV2!
  file: File
  fileContentType: FileContentTypeV2!
  """The ID of an object"""
  id: ID!
  title: String!
}

"""Data only accessible by the admin"""
type FilesAdminMutationSchema {
  deleteFile(input: DeleteFileInput!): DeleteFilePayload
}

"""Data only accessible by the admin"""
type FilesAdminSchema {
  Files(after: String, before: String, fileType: [String!], first: Int, fromDateTimeInclusive: ZonedDateTIme, last: Int, name: String, tagsExcluded: [String!], tagsIncluded: [String!], toDateTimeInclusive: ZonedDateTIme): FilesConnection!
}

"""A connection to a list of items."""
type FilesConnection {
  """A list of edges."""
  edges: [FilesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type FilesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: File!
}

interface FinishedAsyncContentSubmissionDefinitionInterface {
  contentKind: ContentKind!
  element: AsyncLearnElement
  rewardResults: [RewardResult!]!
  status: ContentSubmissionStatus!
}

interface FinishedELearningContentSubmissionDefinitionInterface {
  contentKind: ContentKind!
  progress: ELearningContentSubmissionProgress!
  relativeProgress: ELearningContentSubmissionRelativeProgress!
  rewardResults: [RewardResult!]!
  status: ContentSubmissionStatus!
}

type FinishedELearningContentSubmissionProgress implements ELearningContentSubmissionProgress {
  percentage: Int!
}

type FinishedTreeStateDefinition implements TreeStateDefinition {
  status: TreeStateStatus!
}

type FirstContentStartAtTreeConfig implements StartAtTreeConfig {
  configType: StartAtTreeConfigType!
  """The ID of an object"""
  id: ID!
}

interface FlowELearningContentConfig {
  configType: FlowELearningContentConfigType!
  """The ID of an object"""
  id: ID!
}

enum FlowELearningContentConfigType {
  FlowELearningContent_DirectFeedback
  FlowELearningContent_SimplyContinue
}

input ForgotPasswordInput {
  clientMutationId: String
  email: String!
}

type ForgotPasswordPayload {
  clientMutationId: String
}

type FreshUploadAsyncElementTask implements AsyncElementTask & Node & UploadAsyncElementTask {
  assignedEvaluator: User
  elementKind: AsyncElementKind!
  extension: AsyncElementTaskExtension!
  file: File
  id: ID!
  status: AsyncElementTaskStatus!
  submissionInfo: AsyncElementTaskSubmissionInfo!
}

interface GamificationPoints {
  id: ID!
  kind: GamificationPointsKind!
  num: Int!
  owner: User
  receivedAt: ZonedDateTIme!
}

enum GamificationPointsKind {
  ReceivedByContent
}

type GamificationPointsReceivedByContent implements GamificationPoints {
  contentId: ID!
  id: ID!
  kind: GamificationPointsKind!
  num: Int!
  owner: User
  receivedAt: ZonedDateTIme!
}

type GamificationPointsReward implements Reward {
  """The ID of an object"""
  id: ID!
  kind: RewardKind!
  superId: ID!
}

type GamificationPoints_AlreadyReceivedPointsRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type GamificationPoints_ErrorOccurredRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type GamificationPoints_NoPointsReceivedRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type GamificationPoints_NotPassedIHKTestFlowRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type GamificationPoints_PointsReceivedRewardResult implements RewardResult {
  kind: RewardResultKind!
  points: GamificationPointsReceivedByContent
  rewardId: ID!
  rewardKind: RewardKind!
}

enum Gender {
  Diverse
  Female
  Male
  NotDefined
}

input GenerateAbsoluteCartLinkInput {
  clientMutationId: String
  selectedDiscountCodes: [String!]!
  selectedProducts: [CartLinkProductsInput!]!
}

type GenerateAbsoluteCartLinkPayload {
  clientMutationId: String
  link: String!
}

type GetActiveContentNodeOrFallbackRoot_ActiveContentNode implements GetActiveContentNodeOrFallbackRoot_Result {
  contentNode: LearnOpportunityV2!
  kind: GetActiveContentNodeOrFallbackRoot_ResultKind!
}

type GetActiveContentNodeOrFallbackRoot_Empty implements GetActiveContentNodeOrFallbackRoot_Result {
  kind: GetActiveContentNodeOrFallbackRoot_ResultKind!
}

type GetActiveContentNodeOrFallbackRoot_FallbackRoot implements GetActiveContentNodeOrFallbackRoot_Result {
  fallbackRoot: LearnOpportunityV2!
  kind: GetActiveContentNodeOrFallbackRoot_ResultKind!
}

interface GetActiveContentNodeOrFallbackRoot_Result {
  kind: GetActiveContentNodeOrFallbackRoot_ResultKind!
}

enum GetActiveContentNodeOrFallbackRoot_ResultKind {
  ActiveContentNode
  Empty
  FallbackRoot
}

input GetVideoDataV2Input {
  clientMutationId: String
  vimeoId: String!
  vimeoVideoSourceId: ID!
}

type GetVideoDataV2Payload {
  clientMutationId: String
  videoData: VideoDataV2
}

type GlobalVocabElement implements ElementV2 {
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  title: String!
}

input GoToNextElementInput {
  clientMutationId: String
  contentSubmissionId: ID!
}

type GoToNextElementPayload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

input GoToPreviousElementInput {
  clientMutationId: String
  contentSubmissionId: ID!
}

type GoToPreviousElementPayload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

type GoogleIAPData implements PaymentProviderData {
  dataType: PaymentProviderDataType!
  orderId: ID!
  paymentMethod: PaymentMethodType!
  receipt: String!
}

input GrantPlacementPermissionAndRedirectInput {
  clientMutationId: String
}

type GrantPlacementPermissionAndRedirectPayload {
  clientMutationId: String
  placementUrl: String!
}

type GroupCoachingSetting implements CoachingSetting {
  kind: CoachingSettingKind!
  maxParticipants: Int!
}

input GroupCoachingSettingInput {
  kind: CoachingSettingKind
  maxParticipants: Int!
}

type HeadingAndDescription {
  description: String!
  heading: String!
}

input HeadingAndDescriptionInput {
  description: String!
  heading: String!
}

type HideVisibilityCoachingConfig implements VisibilityCoachingConfig {
  configType: VisibilityCoachingConfigType!
  """The ID of an object"""
  id: ID!
}

type HideVisibilityTreeConfig implements VisibilityTreeConfig {
  configType: VisibilityTreeConfigType!
  """The ID of an object"""
  id: ID!
}

interface HistoryEventInterface {
  kind: HistoryEventType!
}

enum HistoryEventType {
  BillingDetailsUpdate
  CartUpdate
  CreditNoteSentUpdate
  InvoiceSentUpdate
  OrderCreationUpdate
  PaymentInProcessUpdate
  PaymentMethodUpdate
  PurchaseUpdate
}

"""Data only accessible by the admin"""
type HubspotAdminMutationSchema {
  syncHubspotContactsWithUsers(input: SyncHubspotContactsWithUsersInput!): SyncHubspotContactsWithUsersPayload
}

enum IHKCertificateOrderStateKind {
  ErrorOccurred
  NotIHK
  Ordered
  ReadyToOrder
  RewardNotAchievedYet
}

input IHKCertificateOrderUserDataInput {
  city: String!
  country: String!
  dateOfBirth: LocalDate!
  firstName: String!
  houseNumber: String!
  lastName: String!
  postalCode: String!
  salutation: String
  street: String!
  title: String
}

type IHKCertificateReward implements Reward {
  """The ID of an object"""
  id: ID!
  kind: RewardKind!
  superId: ID!
}

type IHKCertificate_ErrorOccurredRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type IHKCertificate_NotPassedRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type IHKCertificate_ReadyToOrderRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type IHKFlowPassContentConfig implements PassContentConfig {
  configType: PassContentConfigType!
  """The ID of an object"""
  id: ID!
}

enum Icon {
  arrowLoop
  bridgeOverRiver
  computerWithHeart
  dotsConnected
  flowerInCircle
  handWithFlower
  handsWithHeart
  lightBulb
  peopleHighFive
  personWithStars
  rocket
  workingDesk
}

type ImageTrendMedia implements TrendMedia {
  file: File
  kind: TrendMediaKind!
}

input ImageTrendMediaInput {
  fileId: ID!
  trendMediaType: TrendMediaKind!
}

input InformAboutSuccessfulPlacementInput {
  accountId: ID!
  clientMutationId: String
  jobListingTitle: String!
}

type InformAboutSuccessfulPlacementPayload {
  clientMutationId: String
}

input InitializeFreeCalendarWeekOverrideInput {
  clientMutationId: String
}

type InitializeFreeCalendarWeekOverridePayload {
  clientMutationId: String
  schedule: AvailabilitySchedule!
}

type InputAndIsCorrectElementState implements ElementState {
  element: LearnElement!
  inputElementState: InputElementState!
  isCorrect: Boolean!
  kind: ElementStateKind!
}

interface InputElementState {
  element: LearnElement!
  kind: ElementStateKind!
}

interface Instructor {
  """The ID of an object"""
  id: ID!
  name: String!
  superId: ID!
}

"""Data only accessible by the admin"""
type InstructorAdminMutationSchema {
  createInstructorImpl(input: CreateInstructorImplInput!): CreateInstructorImplPayload
  deleteInstructorImpl(input: DeleteInstructorImplInput!): DeleteInstructorImplPayload
  updateInstructorImpl(input: UpdateInstructorImplInput!): UpdateInstructorImplPayload
}

"""Data only accessible by the admin"""
type InstructorAdminSchema {
  InstructorImpls(after: String, before: String, first: Int, last: Int): InstructorImplsConnection!
}

type InstructorImpl implements Instructor & Node {
  description: String
  """The ID of an object"""
  id: ID!
  image: File
  name: String!
  position: String
  shortDescription: String
  superId: ID!
}

input InstructorImplInput {
  clientMutationId: String
  description: String
  imageId: ID
  name: String!
  position: String
  shortDescription: String
}

"""A connection to a list of items."""
type InstructorImplsConnection {
  """A list of edges."""
  edges: [InstructorImplsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type InstructorImplsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: InstructorImpl!
}

"""A connection to a list of items."""
type InstructorsConnection {
  """A list of edges."""
  edges: [InstructorsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type InstructorsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Instructor!
}

type Invitation {
  accountName: String
  addToGroups: [UserInAccountGroup!]!
  email: String!
  """The ID of an object"""
  id: ID!
  invitingUser: User
  invitingUserName: String
  validUntil: ZonedDateTIme
}

type InvitationWrapper implements AccountMember {
  groups: [UserInAccountGroup!]!
  id: ID!
  invitation: Invitation!
  isManager: Boolean!
  kind: AccountMemberKind!
  name: String!
}

input InviteOrAddUsersToUserInAccountGroupsInput {
  clientMutationId: String
  emails: [String!]!
  groupIds: [ID!]!
}

type InviteOrAddUsersToUserInAccountGroupsPayload {
  clientMutationId: String
  newAccountMembers: [AccountMemberEdge!]!
  updatedAccountMembers: [AccountMember!]!
}

type InvoiceAddress {
  city: String!
  companyDetails: String
  companyName: String!
  country: String!
  firstName: String!
  houseNumber: String!
  lastName: String!
  postalCode: String!
  street: String!
}

interface InvoiceData {
  kind: InvoiceDataKind!
}

enum InvoiceDataKind {
  Creatable
  Created
  Empty
  StripeEmpty
}

type InvoiceSentUpdate implements HistoryEventInterface {
  invoiceId: String!
  invoiceNumber: String!
  kind: HistoryEventType!
}

type IsFinishedViewerTreeState implements ViewerTreeState {
  kind: ViewerTreeStateKind!
  startedAt: ZonedDateTIme!
}

type IsStartedViewerTreeState implements ViewerTreeState {
  headContentId: ID!
  kind: ViewerTreeStateKind!
  startedAt: ZonedDateTIme!
}

input IssueExternalLicenseInput {
  clientMutationId: String
  externalLicenseId: ID!
  issuedToUser: ID!
}

type IssueExternalLicensePayload {
  clientMutationId: String
  edge: ExternalLicensesEdge!
}

interface Item {
  itemType: ItemType!
}

enum ItemType {
  CartBulkDiscount
  CartDiscount
  CartGlobalDiscount
  CartLimitedDiscount
  CartProduct
}

type JwtLoginInformation {
  accessToken: String!
  refreshToken: String!
}

enum Kind {
  Assigment
  FreeForAll
}

type LearnAsyncContentTypeDefinition implements LearnOpportunityContentTypeDefinition & LearnOpportunityTypeDefinition {
  contentKind: ContentKind!
  contentNodeAdvancementResult: ContentNodeAdvancementResult!
  definitionType: TypeDefinitionType!
  extension: LearnContentExtension!
  task: AsyncElementTask
  taskDescription: String
}

interface LearnContentExtension {
  doNotUse: String!
}

type LearnContentExtensionImpl implements LearnContentExtension {
  doNotUse: String!
  elementsSummary: ElementsSummary
  image: File
  instructors(after: String, before: String, first: Int, last: Int): InstructorsConnection!
  isUnlockNecessaryToStart: Boolean!
  receivableGamificationPoints: Int!
  receivedGamificationPoints: Int!
}

interface LearnElement {
  elementType: ElementTypeV2!
  """The ID of an object"""
  id: ID!
  title: String!
}

type LearnMutations {
  orderIHKCertificate(input: OrderIHKCertificateInput!): OrderIHKCertificatePayload
}

"""A connection to a list of items."""
type LearnOpportunitiesV2Connection {
  """A list of edges."""
  edges: [LearnOpportunitiesV2Edge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type LearnOpportunitiesV2Edge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: LearnOpportunityV2!
}

type LearnOpportunityBranchTypeDefinition implements LearnOpportunityTypeDefinition {
  children: [LearnOpportunityV2!]!
  definitionType: TypeDefinitionType!
}

type LearnOpportunityChildStructureDefinition implements LearnOpportunityStructureDefinition {
  definitionType: StructureType!
  title: String!
}

interface LearnOpportunityContentTypeDefinition {
  contentKind: ContentKind!
  contentNodeAdvancementResult: ContentNodeAdvancementResult!
  definitionType: TypeDefinitionType!
  extension: LearnContentExtension!
}

type LearnOpportunityELearningContentTypeDefinition implements LearnOpportunityContentTypeDefinition & LearnOpportunityTypeDefinition {
  containedElementTypes: [ElementTypeV2!]!
  contentKind: ContentKind!
  contentNodeAdvancementResult: ContentNodeAdvancementResult!
  definitionType: TypeDefinitionType!
  extension: LearnContentExtension!
  showAnswerElements: [ElementV2!]
}

interface LearnOpportunityRootExtension {
  doNotUse: String!
}

type LearnOpportunityRootStructureDefinition implements LearnOpportunityStructureDefinition {
  definitionType: StructureType!
  extension: LearnOpportunityRootExtension!
  icon: File
  progressPercentage: Int
  tags: [Tag!]!
  title: String!
  viewerTreeState: ViewerTreeState!
}

interface LearnOpportunityStructureDefinition {
  definitionType: StructureType!
  title: String!
}

interface LearnOpportunityTypeDefinition {
  definitionType: TypeDefinitionType!
}

type LearnOpportunityV2 implements Node {
  attachmentsV2: [AttachmentV2!]!
  description: String
  """The ID of an object"""
  id: ID!
  image: File
  indexPath: [Int!]!
  instructors: [Instructor!]!
  instructorsV2(after: String, before: String, first: Int, last: Int): InstructorsConnection!
  lengthInSecondsV2: Int!
  nextContentNode: LearnOpportunityV2
  nextContentNodeId: ID
  path: [LearnOpportunityV2!]!
  previousContentNodeId: ID
  root: LearnOpportunityV2
  shortDescription: String
  structureDefinition: LearnOpportunityStructureDefinition!
  typeDefinition: LearnOpportunityTypeDefinition!
}

type LearnQueries {
  Tags(after: String, before: String, first: Int, last: Int): TagsConnection!
}

"""Data only accessible by the admin"""
type LearnV2AdminMutationSchema {
  createTreeStateForUser(input: CreateTreeStateForUserInput!): CreateTreeStateForUserPayload
  deleteTree(input: DeleteTreeInput!): DeleteTreePayload
  setTreeStateHead(input: SetTreeStateHeadInput!): SetTreeStateHeadPayload
}

"""Data only accessible by the admin"""
type LearnV2AdminSchema {
  GetContentSubmissions(after: String, before: String, first: Int, last: Int, treeStateId: ID!): ContentSubmissionsConnection!
  GetTreeStates(after: String, before: String, filterByRootNodeId: ID, filterByUserId: ID, first: Int, last: Int): TreeStatesConnection!
  RootNodesWithTreeStatesForUser(after: String, before: String, first: Int, last: Int, name: String, userId: ID!): [RootNodesWithTreeStateType!]!
  SearchLearnOpportunityV2(after: String, before: String, first: Int, last: Int, titleMatchRegex: String): LearnOpportunitiesV2Connection!
}

type LearnV2Mutations {
  restartContentNodeAfterFailed(input: RestartContentNodeAfterFailedInput!): RestartContentNodeAfterFailedPayload
  restartContentNodeAfterPassed(input: RestartContentNodeAfterPassedInput!): RestartContentNodeAfterPassedPayload
  startContentNode(input: StartContentNodeInput!): StartContentNodePayload
  startTree(input: StartTreeInput!): StartTreePayload
  submitClozeTextElement(input: SubmitClozeTextElementV2Input!): SubmitClozeTextElementV2Payload
  submitDisplayElement(input: SubmitDisplayElementInput!): SubmitDisplayElementPayload
  submitMarkMistakesElement(input: SubmitMarkMistakesElementV2Input!): SubmitMarkMistakesElementV2Payload
  submitMatrixElement(input: SubmitMatrixElementV2Input!): SubmitMatrixElementV2Payload
  submitMultipleChoiceElement(input: SubmitMultipleChoiceElementV2Input!): SubmitMultipleChoiceElementV2Payload
  submitOrderElement(input: SubmitOrderElementInput!): SubmitOrderElementPayload
}

"""Data partaining to the current user"""
type LearnViewerSchema {
  getActiveContentNodeOrFallbackRoot: GetActiveContentNodeOrFallbackRoot_Result!
  getActiveRoots: [LearnOpportunityV2!]!
  myNodeDocuments: [File!]!
}

"""Data only accessible by the admin"""
type LearnableAdminSchema {
  UnpublishedLearnables(after: String, before: String, first: Int, isVisible: Boolean, kinds: [LearnableKind!]!, last: Int, tagIds: [ID!]!, text: String): UnpublishedLearnablesConnection!
}

enum LearnableKind {
  Course
  GroupCoaching
  MicroLearning
  OneToOneCoaching
}

type LearnableLicenseGrouping implements LicenseGrouping {
  assignmentRules: [AssignmentRule!]!
  id: ID!
  kind: LicenseGroupingKind!
  learnable: PublishedLearnable
  totalLicenseAmount: Int!
  totalLicenseAmountForUser: Int!
  usedLicenseAmount: Int!
  usedLicenseAmountForUser: Int!
}

type LearnableQueries {
  PublishedLearnables(after: String, before: String, first: Int, kinds: [LearnableKind!]!, last: Int, tagIds: [ID!]!, text: String): PublishedLearnablesConnection!
}

type LearnableWithLastUpdated {
  lastUpdated: ZonedDateTIme
  learnable: PublishedLearnable!
}

input LeaveAccountInput {
  clientMutationId: String
}

type LeaveAccountPayload {
  clientMutationId: String
}

input LeaveFeedbackInput {
  availabilityId: ID!
  clientMutationId: String
  feedbackData: FeedbackData!
}

type LeaveFeedbackPayload {
  availability: Availability!
  clientMutationId: String
}

type License {
  creationInfo: LicenseCreationInfo!
  """The ID of an object"""
  id: ID!
  usage: LicenseUsage!
}

interface LicenseAvailability {
  kind: LicenseAvailabilityKind!
}

type LicenseAvailabilityFreeLicensesAvailable implements LicenseAvailability {
  kind: LicenseAvailabilityKind!
  numAvailable: Int!
}

enum LicenseAvailabilityKind {
  FreeLicensesAvailable
  NoneAvailable
}

type LicenseAvailabilityNoneAvailableType implements LicenseAvailability {
  kind: LicenseAvailabilityKind!
}

"""A connection to a list of items."""
type LicenseConnection {
  """A list of edges."""
  edges: [LicenseEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type LicenseCreatedByAdmin implements LicenseCreationInfo {
  createdAt: ZonedDateTIme!
  creatorId: ID!
  kind: LicenseCreationInfoKind!
  licenseDefinition: LicenseDefinition
}

type LicenseCreatedByOrder implements LicenseCreationInfo {
  createdAt: ZonedDateTIme!
  kind: LicenseCreationInfoKind!
  licenseDefinition: LicenseDefinition
  orderId: ID!
}

type LicenseCreatedByPlacement implements LicenseCreationInfo {
  createdAt: ZonedDateTIme!
  kind: LicenseCreationInfoKind!
  licenseDefinition: LicenseDefinition
}

type LicenseCreatedByPotentialAnalysis implements LicenseCreationInfo {
  createdAt: ZonedDateTIme!
  fromUserId: ID!
  kind: LicenseCreationInfoKind!
  licenseDefinition: LicenseDefinition
}

type LicenseCreatedByRegistration implements LicenseCreationInfo {
  createdAt: ZonedDateTIme!
  kind: LicenseCreationInfoKind!
  licenseDefinition: LicenseDefinition
  userId: ID!
}

interface LicenseCreationInfo {
  createdAt: ZonedDateTIme!
  kind: LicenseCreationInfoKind!
  licenseDefinition: LicenseDefinition
}

enum LicenseCreationInfoKind {
  Admin
  Order
  Placement
  PotentialAnalysis
  Registration
}

type LicenseDefinition implements Node {
  data: LicenseDefinitionData!
  """The ID of an object"""
  id: ID!
}

"""Data only accessible by the admin"""
type LicenseDefinitionAdminMutationSchema {
  createAVGSPotentialAnalysisLicenseDefinition(input: CreateAVGSPotentialAnalysisLicenseDefinitionInput!): CreateAVGSPotentialAnalysisLicenseDefinitionPayload
  createCoachingLicenseDefinition(input: CreateCoachingLicenseDefinitionInput!): CreateCoachingLicenseDefinitionPayload
  createMicroLearningLicenseDefinition(input: CreateMicroLearningLicenseDefinitionInput!): CreateMicroLearningLicenseDefinitionPayload
  createTreeLicenseDefinition(input: CreateTreeLicenseDefinitionInput!): CreateTreeLicenseDefinitionPayload
  deleteLicenseDefinition(input: DeleteLicenseDefinitionInput!): DeleteLicenseDefinitionPayload
  editAVGSPotentialAnalysisLicenseDefinitionAdminMutation(input: EditAVGSPotentialAnalysisLicenseDefinitionAdminMutationInput!): EditAVGSPotentialAnalysisLicenseDefinitionAdminMutationPayload
  editCoachingLicenseDefinitionAdminMutation(input: EditCoachingLicenseDefinitionAdminMutationInput!): EditCoachingLicenseDefinitionAdminMutationPayload
  editMicroLicenseDefinitionAdminMutation(input: EditMicroLearningLicenseDefinitionAdminMutationInput!): EditMicroLearningLicenseDefinitionAdminMutationPayload
  editTreeLicenseDefinitionAdminMutation(input: EditTreeLicenseDefinitionAdminMutationInput!): EditTreeLicenseDefinitionAdminMutationPayload
}

"""Data only accessible by the admin"""
type LicenseDefinitionAdminSchema {
  SearchLicenseDefinitions(after: String, before: String, dataKinds: [LicenseDefinitionDataKind!]!, first: Int, last: Int, nameMatchRegex: String): LicenseDefinitionsConnection!
}

type LicenseDefinitionCoachingInfo {
  coachingId: ID!
  contractPartner: ContractPartner
  image: File
  title: String!
}

interface LicenseDefinitionData {
  kind: LicenseDefinitionDataKind!
  name: String!
}

enum LicenseDefinitionDataKind {
  AVGSPotentialAnalysis
  Coaching
  MicroLearning
  Tree
}

type LicenseDefinitionRootInfo {
  contractPartner: ContractPartner
  image: File
  rootId: ID!
  title: String!
}

"""A connection to a list of items."""
type LicenseDefinitionsConnection {
  """A list of edges."""
  edges: [LicenseDefinitionsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type LicenseDefinitionsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: LicenseDefinition!
}

"""An edge in a connection."""
type LicenseEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: License!
}

interface LicenseGrouping {
  assignmentRules: [AssignmentRule!]!
  id: ID!
  kind: LicenseGroupingKind!
  totalLicenseAmount: Int!
  totalLicenseAmountForUser: Int!
  usedLicenseAmount: Int!
  usedLicenseAmountForUser: Int!
}

enum LicenseGroupingKind {
  Learnable
  MicroLearning
}

type LicenseGroupingQueries {
  LicenseGrouping(id: ID!): LicenseGrouping!
  LicenseGroupings(after: String, before: String, first: Int, kinds: [LearnableKind!]!, last: Int, licensesAvailable: Boolean, licensesConsumed: Boolean, text: String): LicenseGroupingsConnection!
  MyLicenses(after: String, before: String, first: Int, kinds: [LearnableKind!]!, last: Int, licensesAvailable: Boolean, licensesConsumed: Boolean, text: String): LicenseGroupingsConnection!
}

"""A connection to a list of items."""
type LicenseGroupingsConnection {
  """A list of edges."""
  edges: [LicenseGroupingsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type LicenseGroupingsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: LicenseGrouping!
}

type LicenseManagementMutations {
  createAccountGroupAssignmentRule(input: CreateAccountGroupAssignmentRuleInput!): CreateAccountGroupAssignmentRulePayload
  createSingleUserAssignmentRule(input: CreateSingleUserAssignmentRuleInput!): CreateSingleUserAssignmentRulePayload
  deleteAssignmentRule(input: DeleteAssignmentRuleInput!): DeleteAssignmentRulePayload
  editAccountGroupAssignmentRule(input: EditAccountGroupAssignmentRuleInput!): EditAccountGroupAssignmentRulePayload
  editSingleUserAssignmentRule(input: EditSingleUserAssignmentRuleInput!): EditSingleUserAssignmentRulePayload
}

type LicenseModelMutations {
  editLicenseModel(input: EditLicenseModelInput!): EditLicenseModelPayload
}

type LicenseProductData implements ProductData {
  kind: ProductKind!
  licenseDefinition: LicenseDefinition
  licenseDefinitionAmount: Int
}

interface LicenseUsage {
  kind: LicenseUsageKind!
}

type LicenseUsageFree implements LicenseUsage {
  kind: LicenseUsageKind!
}

enum LicenseUsageKind {
  Free
  UsedForAVGSPotentialAnalysis
  UsedForCoaching
  UsedForTree
}

type LicenseUsageUsedForCoaching implements LicenseUsage & LicenseUsed {
  at: ZonedDateTIme!
  forUser: User
  kind: LicenseUsageKind!
}

type LicenseUsageUsedForTree implements LicenseUsage & LicenseUsed {
  at: ZonedDateTIme!
  forUser: User
  kind: LicenseUsageKind!
}

interface LicenseUsed {
  at: ZonedDateTIme!
  forUser: User
  kind: LicenseUsageKind!
}

type LicenseUsedForCreatingAVGSPotentialAnalysis implements LicenseUsage & LicenseUsed {
  at: ZonedDateTIme!
  forUser: User
  kind: LicenseUsageKind!
}

type LicensesGroupedByDefinition {
  definition: LicenseDefinition
  numFree: Int!
  numUsed: Int!
  usedBy: [User!]!
}

"""A connection to a list of items."""
type LicensesGroupedByDefinitionConnection {
  """A list of edges."""
  edges: [LicensesGroupedByDefinitionEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type LicensesGroupedByDefinitionEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: LicensesGroupedByDefinition!
}

type LimitedCartDiscount implements Node {
  conditions: [LimitedCartDiscountCondition!]!
  createdAt: ZonedDateTIme!
  """The ID of an object"""
  id: ID!
  productSelectionConfig: ProductSelectionConfig!
  title: String!
}

interface LimitedCartDiscountCondition {
  """The ID of an object"""
  id: ID!
  kind: LimitedCartDiscountConditionKindEnum!
}

enum LimitedCartDiscountConditionKindEnum {
  ProductSelectionCondition
}

"""A connection to a list of items."""
type LimitedCartDiscountConnection {
  """A list of edges."""
  edges: [LimitedCartDiscountEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type LimitedCartDiscountEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: LimitedCartDiscount!
}

scalar LocalDate

scalar LocalTime

input LoginAsUserJwtInput {
  clientMutationId: String
  userId: ID!
}

type LoginAsUserJwtPayload {
  clientMutationId: String
  jwtTokens: JwtLoginInformation!
}

input LoginInput {
  clientMutationId: String
  email: String!
  password: String!
}

input LoginJwtInput {
  clientMutationId: String
  email: String!
  password: String!
}

type LoginJwtPayload {
  clientMutationId: String
  loginResult: LoginResult!
}

type LoginPayload {
  accounts: [Account!]!
  clientMutationId: String
  groupAssociations: [UserGroupAssociation!]!
  permissionsInAccounts: [AccountPermissions!]!
  token: String!
  userId: ID!
}

type LoginResult {
  extension: LoginResultExtension!
  firstLogin: Boolean!
  jwtTokens: JwtLoginInformation!
}

interface LoginResultExtension {
  doNotUse: String!
}

input LogoutJwtInput {
  clientMutationId: String
}

type LogoutJwtPayload {
  clientMutationId: String
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

"""Data only accessible by the admin"""
type ManagementAdminSchema {
  AccountGroups(after: String, before: String, first: Int, last: Int): AccountGroupsConnection!
  UsersAdmin(after: String, alwaysIncludeIds: [ID!], before: String, excludeIds: [ID!], filterByName: String, first: Int, last: Int): UserConnection!
}

type ManagementQueries {
  Groups(after: String, before: String, first: Int, last: Int): UserInAccountGroupsConnection!
}

type MandateInformation {
  acceptanceDateTime: ZonedDateTIme!
  mandateNumber: String!
}

type MarkMistakesElement implements ElementV2 {
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  text: String!
  title: String!
}

type MarkMistakesInputElementState implements ElementState & InputElementState {
  checkedMistakeIndices: [Int!]!
  element: LearnElement!
  kind: ElementStateKind!
}

type MarkMistakesLearnElement implements LearnElement {
  elementType: ElementTypeV2!
  """The ID of an object"""
  id: ID!
  snippets: [MarkMistakes_Snippet!]!
  title: String!
}

type MarkMistakesShowAnswerElementState implements ElementState & ShowAnswerElementState {
  correctMistakeIndices: [Int!]!
  element: LearnElement!
  kind: ElementStateKind!
  lastCheckedMistakeIndices: [Int!]
}

type MarkMistakes_Snippet {
  content: String!
}

type MatrixElement implements ElementV2 {
  cells: [MatrixElementCell!]!
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  title: String!
}

interface MatrixElementCell {
  """The ID of an object"""
  id: ID!
  kind: MatrixElementCellKind!
  xIdx: Int!
  yIdx: Int!
}

interface MatrixElementCellAnswer {
  content: String!
  isCorrect: Boolean!
}

type MatrixElementCellCorrectAnswer implements MatrixElementCellAnswer {
  content: String!
  isCorrect: Boolean!
}

enum MatrixElementCellKind {
  Answer
  Display
}

type MatrixElementCellWrongAnswer implements MatrixElementCellAnswer {
  content: String!
  """The ID of an object"""
  id: ID!
  isCorrect: Boolean!
}

type MatrixInputElementState implements ElementState & InputElementState {
  checkedIndices: [MatrixLearnElementIndexCell!]!
  element: LearnElement!
  kind: ElementStateKind!
}

type MatrixLearnElement implements LearnElement {
  cells: [MatrixLearnElementCell!]!
  elementType: ElementTypeV2!
  """The ID of an object"""
  id: ID!
  title: String!
}

type MatrixLearnElementAnswer {
  content: String!
}

interface MatrixLearnElementCell {
  kind: MatrixElementCellKind!
  xIdx: Int!
  yIdx: Int!
}

type MatrixLearnElementIndexCell {
  index: Int!
  xIdx: Int!
  yIdx: Int!
}

type MatrixShowAnswerElementState implements ElementState & ShowAnswerElementState {
  correctIndices: [MatrixLearnElementIndexCell!]!
  element: LearnElement!
  kind: ElementStateKind!
  lastCheckedIndices: [MatrixLearnElementIndexCell!]
}

type MicroLearningLicenseDefinitionData implements LicenseDefinitionData {
  kind: LicenseDefinitionDataKind!
  name: String!
}

input MicroLearningLicenseDefinitionDataInput {
  name: String!
}

type MicroLearningLicenseGrouping implements LicenseGrouping {
  assignmentRules: [AssignmentRule!]!
  id: ID!
  kind: LicenseGroupingKind!
  totalLicenseAmount: Int!
  totalLicenseAmountForUser: Int!
  usedLicenseAmount: Int!
  usedLicenseAmountForUser: Int!
}

type MonthlyOption {
  closingRate: Price!
  downPayment: Price!
  financedAmount: Price!
  monthlyRate: Price!
  paymentMethodTypes: [PaymentMethodType!]!
  rateCount: Int!
  totalAmount: Price!
}

type MonthlySelectedPaymentMethod implements SelectedPaymentMethod {
  chosenOption: MonthlyOption!
  paymentMethodId: PaymentMethodType!
  selectedPaymentMethodType: SelectedPaymentMethodType!
}

input MoveChildNodeInput {
  childToBeMovedId: ID!
  clientMutationId: String
  newParentId: ID!
  newPreviousSiblingId: ID
}

type MoveChildNodePayload {
  clientMutationId: String
  tree: Tree!
}

input MoveOrderItemsInput {
  clientMutationId: String
  orderElementId: ID!
  orderItemIds: [ID!]!
}

type MoveOrderItemsPayload {
  clientMutationId: String
  orderElement: OrderElement!
}

type MultipleChoiceElementV2 implements ElementV2 {
  answerOptions: [AnswerOptionV2!]!
  answeringType: AnsweringTypeV2!
  answeringTypeText: String
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  image: File
  question: String!
  title: String!
}

type MultipleChoiceInputElementState implements ElementState & InputElementState {
  checkedAnswerIndices: [Int!]!
  element: LearnElement!
  kind: ElementStateKind!
}

type MultipleChoiceLearnElement implements LearnElement {
  answerOptions: [AnswerOptionWithoutCorrect!]!
  answeringType: AnsweringTypeV2!
  answeringTypeText: String
  elementType: ElementTypeV2!
  """The ID of an object"""
  id: ID!
  image: File
  question: String!
  title: String!
}

type MultipleChoiceShowAnswerElementState implements ElementState & ShowAnswerElementState {
  correctAnswerIndices: [Int!]!
  element: LearnElement!
  kind: ElementStateKind!
  lastCheckedAnswerIndices: [Int!]
}

type Mutation {
  AccountBaseData: AccountBaseDataMutations!
  AccountMemberManagement: AccountMemberManagementMutations!
  """Data only accessible by the admin"""
  Admin: AdminMutationType!
  AsyncContent: AsyncContentMutations!
  Auth: AuthMutations!
  AvgsPotentialAnalysis: AvgsPotentialAnalysisMutations!
  Billing: BillingMutations!
  Coaching: CoachingMutations!
  ELearning: ELearningMutations!
  Learn: LearnMutations!
  LearnV2: LearnV2Mutations!
  LicenseManagement: LicenseManagementMutations!
  LicenseModel: LicenseModelMutations!
  Notification: NotificationMutations!
  Placement: PlacementMutations!
  PotentialAnalysis: PotentialAnalysisMutations!
  Reports: ReportsMutations!
  """Data partaining to the current user"""
  Viewer: ViewerMutationType!
  Vocab: VocabMutations!
}

type NegativeBlockPermanentlyRestartIfFailedContentConfigResult implements NegativeRestartIfFailedContentConfigResult & RestartIfFailedContentConfigResult {
  canBeRestarted: Boolean!
  configType: RestartIfFailedContentConfigType!
}

type NegativeBlockTemporarilyRestartIfFailedContentConfigResult implements NegativeRestartIfFailedContentConfigResult & RestartIfFailedContentConfigResult {
  blockedUntil: ZonedDateTIme!
  canBeRestarted: Boolean!
  configType: RestartIfFailedContentConfigType!
}

type NegativeCanNotRestartIfFailedContentConfigResult implements NegativeRestartIfFailedContentConfigResult & RestartIfFailedContentConfigResult {
  canBeRestarted: Boolean!
  configType: RestartIfFailedContentConfigType!
}

interface NegativeRestartIfFailedContentConfigResult {
  canBeRestarted: Boolean!
  configType: RestartIfFailedContentConfigType!
}

type NoPodcastSourceV2 implements PodcastSourceV2 {
  sourceType: PodcastSourceTypeV2!
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

type NotAfterDateTimeVisibilityTreeConfig implements VisibilityTreeConfig {
  configType: VisibilityTreeConfigType!
  dateTime: ZonedDateTIme!
  """The ID of an object"""
  id: ID!
}

type NotBooked implements BookingInterface {
  kind: BookingKind!
}

type NotContentNodeContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  status: ContentNodeAdvancementStatus!
}

type NotVisibleViewerTreeState implements ViewerTreeState {
  kind: ViewerTreeStateKind!
  reasonConfigTypes: [VisibilityTreeConfigType!]!
}

"""Data only accessible by the admin"""
type NotificationAdminMutationSchema {
  createPersonalizedNotificationTemplate(input: CreatePersonalizedNotificationTemplateInput!): CreatePersonalizedNotificationTemplatePayload
  deletePersonalizedNotificationTemplate(input: DeletePersonalizedNotificationTemplateInput!): DeletePersonalizedNotificationTemplatePayload
  updatePersonalizedNotificationTemplate(input: UpdatePersonalizedNotificationTemplateInput!): UpdatePersonalizedNotificationTemplatePayload
}

"""Data only accessible by the admin"""
type NotificationAdminSchema {
  AvailableSystemTemplates(after: String, before: String, first: Int, last: Int): [NotificationTemplate!]!
  PersonalizedNotificationTemplates(after: String, before: String, first: Int, last: Int): PersonalizedNotificationTemplatesConnection!
}

type NotificationMutations {
  registerForNotification(input: RegisterForNotificationInput!): RegisterForNotificationPayload
}

enum NotificationServiceType {
  Apns
  Gcm
}

type NotificationTemplate {
  key: String!
  message: String!
  title: String!
  variables: [String!]!
}

type OneTimeSelectedPaymentMethod implements SelectedPaymentMethod {
  paymentMethodId: PaymentMethodType!
  selectedPaymentMethodType: SelectedPaymentMethodType!
  stripeData: StripeData
}

type OneToOneCoachingSetting implements CoachingSetting {
  kind: CoachingSettingKind!
}

type OnlyAZAVAccountVisibilityCoachingConfig implements VisibilityCoachingConfig {
  configType: VisibilityCoachingConfigType!
  """The ID of an object"""
  id: ID!
}

type OnlyAZAVAccountVisibilityTreeConfig implements VisibilityTreeConfig {
  configType: VisibilityTreeConfigType!
  """The ID of an object"""
  id: ID!
}

type OnlyAdminsVisibilityTreeConfig implements VisibilityTreeConfig {
  configType: VisibilityTreeConfigType!
  """The ID of an object"""
  id: ID!
}

type OnlyBusinessAccountVisibilityCoachingConfig implements VisibilityCoachingConfig {
  configType: VisibilityCoachingConfigType!
  """The ID of an object"""
  id: ID!
}

type OnlyBusinessAccountVisibilityTreeConfig implements VisibilityTreeConfig {
  configType: VisibilityTreeConfigType!
  """The ID of an object"""
  id: ID!
}

type OnlyEditorsVisibilityTreeConfig implements VisibilityTreeConfig {
  configType: VisibilityTreeConfigType!
  """The ID of an object"""
  id: ID!
}

type OnlyIfTreeStateVisibilityTreeConfig implements VisibilityTreeConfig {
  configType: VisibilityTreeConfigType!
  """The ID of an object"""
  id: ID!
}

type OnlyPermissionsImplVisibilityTreeConfig implements VisibilityTreeConfig {
  configType: VisibilityTreeConfigType!
  """The ID of an object"""
  id: ID!
}

type OnlyWithLicenseVisibilityCoachingConfig implements VisibilityCoachingConfig {
  configType: VisibilityCoachingConfigType!
  """The ID of an object"""
  id: ID!
}

type Order implements Node {
  allowedPaymentMethods: [PaymentMethodType!]!
  billingDetails: BillingDetails
  cart: Cart
  createdAt: ZonedDateTIme!
  creditNoteData: CreditNoteData
  extensions: [OrderExtension!]!
  history(after: String, before: String, first: Int, last: Int): OrderHistoriesConnection!
  """The ID of an object"""
  id: ID!
  invoiceData: InvoiceData!
  paymentData: PaymentProviderData
  purchaser: Purchaser
  selectedPaymentDate: ZonedDateTIme
  selectedPaymentMethod: SelectedPaymentMethod
  status: OrderStatus!
}

type OrderCreationUpdate implements HistoryEventInterface {
  kind: HistoryEventType!
}

type OrderElement implements ElementV2 {
  answeringTypeText: String
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  orderItems: [OrderItem!]!
  title: String!
}

interface OrderExtension {
  kind: OrderExtensionKind!
}

enum OrderExtensionKind {
  Empty
}

"""A connection to a list of items."""
type OrderHistoriesConnection {
  """A list of edges."""
  edges: [OrderHistoriesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type OrderHistoriesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: OrderHistory!
}

type OrderHistory {
  createdAt: ZonedDateTIme!
  event: HistoryEventInterface!
  """The ID of an object"""
  id: ID!
  orderId: ID!
  status: OrderStatus!
}

input OrderIHKCertificateInput {
  clientMutationId: String
  rootId: ID!
  userData: IHKCertificateOrderUserDataInput!
}

type OrderIHKCertificatePayload {
  clientMutationId: String
  root: LearnOpportunityV2!
}

type OrderInputElementState implements ElementState & InputElementState {
  element: LearnElement!
  kind: ElementStateKind!
  selectedOrder: [ID!]!
}

type OrderItem {
  """The ID of an object"""
  id: ID!
  text: String!
}

type OrderLearnElement implements LearnElement {
  answeringTypeText: String
  elementType: ElementTypeV2!
  """The ID of an object"""
  id: ID!
  orderItems: [OrderItem!]!
  title: String!
}

type OrderShowAnswerElementState implements ElementState & ShowAnswerElementState {
  correctOrder: [ID!]!
  element: LearnElement!
  kind: ElementStateKind!
  lastSelectedOrder: [ID!]!
}

enum OrderStatus {
  HasBillingDetails
  HasCart
  HasPaymentDetails
  PaymentReceived
  Purchased
  Transient
}

"""A connection to a list of items."""
type OrdersConnection {
  """A list of edges."""
  edges: [OrdersEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type OrdersEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Order!
}

type PackageUnlock {
  unlockedAt: ZonedDateTIme!
  wordPackage: WordPackage
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type Participant {
  participationStatus: ParticipationStatus!
  user: User
}

type ParticipationCertificate {
  html: String!
  name: String!
  variables: [String!]!
}

type ParticipationCertificateReward implements Reward {
  data: ParticipationCertificateRewardData!
  """The ID of an object"""
  id: ID!
  kind: RewardKind!
  superId: ID!
}

type ParticipationCertificateRewardData {
  html: String!
  name: String!
  variables: [ParticipationCertificateRewardVariables!]!
}

input ParticipationCertificateRewardDataInput {
  html: String!
  name: String!
  variables: [ParticipationCertificateRewardDataVariableInput!]!
}

input ParticipationCertificateRewardDataVariableInput {
  key: ParticipationCertificateRewardVariables!
  value: String!
}

enum ParticipationCertificateRewardVariables {
  certificationName
  description
  firstName
  lastName
  partnerName
  shortDesc
  submissionDate
}

type ParticipationCertificate_ErrorOccurredRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type ParticipationCertificate_NotPassedRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type ParticipationCertificate_ParticipationCertificateRewardResult implements RewardResult {
  data: ParticipationCertificate_ParticipationCertificateRewardResultData!
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type ParticipationCertificate_ParticipationCertificateRewardResultData {
  file: File
  name: String!
}

enum ParticipationStatus {
  Absent
  AbsentExcused
  NotConfirmed
  Participated
}

interface PassContentConfig {
  configType: PassContentConfigType!
  """The ID of an object"""
  id: ID!
}

enum PassContentConfigType {
  PassContent_Always
  PassContent_IHKFlow
}

type PassedAsyncContentSubmissionDefinition implements AsyncContentSubmissionDefinition & ContentSubmissionDefinition & FinishedAsyncContentSubmissionDefinitionInterface {
  contentKind: ContentKind!
  element: AsyncLearnElement
  rewardResults: [RewardResult!]!
  status: ContentSubmissionStatus!
}

type PassedELearningContentSubmissionDefinition implements ContentSubmissionDefinition & ELearningContentSubmissionDefinition & FinishedELearningContentSubmissionDefinitionInterface {
  contentKind: ContentKind!
  progress: ELearningContentSubmissionProgress!
  relativeProgress: ELearningContentSubmissionRelativeProgress!
  rewardResults: [RewardResult!]!
  status: ContentSubmissionStatus!
}

input PayOrderInput {
  clientMutationId: String
  iban: String
  orderId: ID!
}

type PayOrderPayload {
  clientMutationId: String
  order: Order!
}

input PayOrderViaIAPInput {
  clientMutationId: String
  orderId: ID!
  receipt: String!
  targetSystem: TargetSystem!
}

type PayOrderViaIAPPayload {
  clientMutationId: String
  order: Order!
}

type PaymentInProcessUpdate implements HistoryEventInterface {
  kind: HistoryEventType!
}

enum PaymentMethodType {
  Card
  Giropay
  IapApple
  IapGoogle
  InvoicePartner
  InvoiceTk
  Klarna
  MonthlyPartner
  MonthlyTk
  Paypal
  Sepa
  Sofort
}

type PaymentMethodUpdate implements HistoryEventInterface {
  kind: HistoryEventType!
}

interface PaymentProviderData {
  dataType: PaymentProviderDataType!
  paymentMethod: PaymentMethodType!
}

enum PaymentProviderDataType {
  AppleIap
  Default
  GoogleIap
  Sepa
  Stripe
  StripeSepa
}

enum PaymentType {
  EmployerInvoice
  MonthlyPayment
  OneTimePayment
}

type PercentageProductSelectionConfig implements ProductSelectionConfig {
  kind: ProductSelectionConfigKindEnum!
  value: Int!
}

enum Permission {
  AccountPermission_AVGSPotentialAnalysis_IsAVGSAccount
  AccountPermission_AZAVAdmin_IsAZAVAccount
  AccountPermission_AccountMemberManagement_CanInviteOrAddUsersToUserInAccountGroups
  AccountPermission_Auth_IsBusinessAccount
  AccountPermission_Auth_usePlacement
  AccountPermission_CoachingCoachProfileAdmin_IsCoachAccount
  AccountPermission_System_Root
  UserInAccountPermission_AVGSPotentialAnalysis_IsAVGSAdmin
  UserInAccountPermission_AVGSPotentialAnalysis_IsAVGSCoach
  UserInAccountPermission_AVGSPotentialAnalysis_ModifyAdmin
  UserInAccountPermission_AVGSPotentialAnalysis_ReadAdmin
  UserInAccountPermission_AZAVAdmin_Modify
  UserInAccountPermission_AZAVAdmin_Read
  UserInAccountPermission_AsyncElementTaskAdmin_Modify
  UserInAccountPermission_AsyncElementTaskAdmin_Read
  UserInAccountPermission_AuthAdmin_MinimalRead
  UserInAccountPermission_AuthAdmin_Modify
  UserInAccountPermission_AuthAdmin_Read
  UserInAccountPermission_Auth_Modify
  UserInAccountPermission_Auth_Read
  UserInAccountPermission_CachingAdmin_Modify
  UserInAccountPermission_CoachBillingAdmin_Read
  UserInAccountPermission_CoachFeedback_Read
  UserInAccountPermission_CoachingAvailabilityAdmin_ModifyAvailability
  UserInAccountPermission_CoachingAvailabilityAdmin_ReadAvailability
  UserInAccountPermission_CoachingCoachProfileAdmin_ModifyCoachProfiles
  UserInAccountPermission_CoachingCoachProfileAdmin_ReadCoachProfiles
  UserInAccountPermission_CoachingOfferAdmin_Modify
  UserInAccountPermission_CoachingOfferAdmin_Read
  UserInAccountPermission_ContractPartnerAdmin_Modify
  UserInAccountPermission_ContractPartnerAdmin_Read
  UserInAccountPermission_CustomerFeedback_Modify
  UserInAccountPermission_CustomerFeedback_Read
  UserInAccountPermission_DiscountAdmin_Modify
  UserInAccountPermission_DiscountAdmin_Read
  UserInAccountPermission_Email_Templates
  UserInAccountPermission_ExternalLicenseAdmin_Modify
  UserInAccountPermission_ExternalLicenseAdmin_Read
  UserInAccountPermission_FeatureToggleAdmin_Modify
  UserInAccountPermission_FeatureToggleAdmin_Read
  UserInAccountPermission_Files_Delete
  UserInAccountPermission_GenerateCartLinkAdmin_Modify
  UserInAccountPermission_Instructors_CreateInstructors
  UserInAccountPermission_Instructors_DeleteInstructors
  UserInAccountPermission_Instructors_ReadInstructors
  UserInAccountPermission_Instructors_UpdateInstructors
  UserInAccountPermission_LearnStates_ReadLearnStates
  UserInAccountPermission_LearnableAdmin_Modify
  UserInAccountPermission_LearnableAdmin_Read
  UserInAccountPermission_LicenseAdmin_Modify
  UserInAccountPermission_LicenseAdmin_Read
  UserInAccountPermission_LicenseDefinitionAdmin_Modify
  UserInAccountPermission_LicenseDefinitionAdmin_Read
  UserInAccountPermission_LimitedCartDiscountAdmin_Modify
  UserInAccountPermission_LimitedCartDiscountAdmin_Read
  UserInAccountPermission_Management_Management
  UserInAccountPermission_Nodes_CreateNodes
  UserInAccountPermission_Nodes_DeleteNodes
  UserInAccountPermission_Nodes_PublishNodes
  UserInAccountPermission_Nodes_ReadNodes
  UserInAccountPermission_Nodes_UpdateNodes
  UserInAccountPermission_OrderAdmin_Modify
  UserInAccountPermission_OrderAdmin_Read
  UserInAccountPermission_PlacementContactPerson_Access
  UserInAccountPermission_ProductAdmin_Modify
  UserInAccountPermission_ProductAdmin_Read
  UserInAccountPermission_ReportAdmin_Modify
  UserInAccountPermission_ReportAdmin_Read
  UserInAccountPermission_SettingsAdmin_Modify
  UserInAccountPermission_SettingsAdmin_Read
  UserInAccountPermission_Submissions_ReadSubmissions
  UserInAccountPermission_System_Owner
  UserInAccountPermission_TagAdmin_Modify
  UserInAccountPermission_TagAdmin_Read
  UserInAccountPermission_TagAdmin_Select
  UserInAccountPermission_Tags_CreateTags
  UserInAccountPermission_Tags_DeleteTags
  UserInAccountPermission_Tags_ReadTags
  UserInAccountPermission_Tags_UpdateTags
  UserInAccountPermission_TreeStateAdmin_Modify
  UserInAccountPermission_TreeStateAdmin_Read
  UserInAccountPermission_Trend_Modify
  UserInAccountPermission_Trend_Read
  UserInAccountPermission_TriggerActionAdmin_Modify
  UserInAccountPermission_TriggerActionAdmin_Read
  UserInAccountPermission_VimeoVideoSourceAdmin_Modify
  UserInAccountPermission_VimeoVideoSourceAdmin_Read
  UserInAccountPermission_VocabAdmin_ModifyWordPackages
  UserInAccountPermission_VocabAdmin_ReadWordPackages
}

type PersonalizedEmailTemplate implements Node {
  """The ID of an object"""
  id: ID!
  template: EmailTemplate!
}

input PersonalizedEmailTemplateInput {
  body: String!
  key: String!
  previewText: String!
  subject: String!
  variables: [String!]!
}

"""A connection to a list of items."""
type PersonalizedEmailTemplatesConnection {
  """A list of edges."""
  edges: [PersonalizedEmailTemplatesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PersonalizedEmailTemplatesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: PersonalizedEmailTemplate!
}

type PersonalizedNotificationTemplate implements Node {
  """The ID of an object"""
  id: ID!
  template: NotificationTemplate!
}

input PersonalizedNotificationTemplateInput {
  key: String!
  message: String!
  title: String!
  variables: [String!]!
}

"""A connection to a list of items."""
type PersonalizedNotificationTemplatesConnection {
  """A list of edges."""
  edges: [PersonalizedNotificationTemplatesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PersonalizedNotificationTemplatesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: PersonalizedNotificationTemplate!
}

type PingQueries {
  """A simple endpoint to find out if the API is reachable"""
  ping: String!
}

type PlacementMutations {
  addMatchingPlacement(input: AddMatchingPlacementInput!): AddMatchingPlacementPayload
  createClickOutByLinkId(input: CreateClickOutByLinkIdInput!): CreateClickOutByLinkIdPayload
  createClickOutForUserOrBusiness(input: CreateClickOutForUserOrBusinessInput!): CreateClickOutForUserOrBusinessPayload
  grantPlacementPermissionAndRedirect(input: GrantPlacementPermissionAndRedirectInput!): GrantPlacementPermissionAndRedirectPayload
  informAboutSuccessfulPlacement(input: InformAboutSuccessfulPlacementInput!): InformAboutSuccessfulPlacementPayload
  sendAskCompanyIfContractWasConcluded(input: SendAskCompanyIfContractWasConcludedInput!): SendAskCompanyIfContractWasConcludedPayload
  sendCompanyIsInterestedInUserProfile(input: SendCompanyIsInterestedInUserProfileInput!): SendCompanyIsInterestedInUserProfilePayload
  sendInformAboutAcceptedMatching(input: SendInformAboutAcceptedMatchingInput!): SendInformAboutAcceptedMatchingPayload
  sendInformAboutAvailableDossier(input: SendInformAboutAvailableDossierInput!): SendInformAboutAvailableDossierPayload
  sendInformAboutClosedProfileAfterMatching(input: SendInformAboutClosedProfileAfterMatchingInput!): SendInformAboutClosedProfileAfterMatchingPayload
  sendMatchingResultsAvailableToBusiness(input: SendMatchingResultsAvailableToBusinessInput!): SendMatchingResultsAvailableToBusinessPayload
  sendMatchingResultsAvailableToUser(input: SendMatchingResultsAvailableToUserInput!): SendMatchingResultsAvailableToUserPayload
  sendRemindCompanyToPayFee(input: SendRemindCompanyToPayFeeInput!): SendRemindCompanyToPayFeePayload
  sendReminderForInviteToSecondInterview(input: SendReminderForInviteToSecondInterviewInput!): SendReminderForInviteToSecondInterviewPayload
  sendReminderForSecondInterviewToUser(input: SendReminderForSecondInterviewToUserInput!): SendReminderForSecondInterviewToUserPayload
  sendSummaryForFirstInterviewToContactPerson(input: SendSummaryForFirstInterviewToContactPersonInput!): SendSummaryForFirstInterviewToContactPersonPayload
  sendSummaryForFirstInterviewToUser(input: SendSummaryForFirstInterviewToUserInput!): SendSummaryForFirstInterviewToUserPayload
  sendSummaryForSecondInterviewToContactPerson(input: SendSummaryForSecondInterviewToContactPersonInput!): SendSummaryForSecondInterviewToContactPersonPayload
  sendSummaryForSecondInterviewToUser(input: SendSummaryForSecondInterviewToUserInput!): SendSummaryForSecondInterviewToUserPayload
  sendUserIsInterestedForJobListing(input: SendUserIsInterestedForJobListingInput!): SendUserIsInterestedForJobListingPayload
}

type PlacementProductData implements ProductData {
  kind: ProductKind!
}

type PlacementQueries {
  PlacementBusinessBaseData(accountId: ID!, after: String, before: String, first: Int, last: Int, userId: ID!): BusinessBaseDataOutput!
  permissionCartClickOut(after: String, before: String, first: Int, last: Int): String!
}

type PodcastElementV2 implements ElementV2 {
  durationInSeconds: Int
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  podcastSource: PodcastSourceV2!
  releasedFileOpt: ReleasedFileV2
  releasedSubtitlesOpt: ReleasedSubtitlesV2
  title: String!
}

type PodcastLearnElement implements LearnElement {
  durationInSeconds: Int
  elementType: ElementTypeV2!
  """The ID of an object"""
  id: ID!
  podcastSource: PodcastSourceV2!
  releasedFileOpt: ReleasedFileV2
  releasedSubtitlesOpt: ReleasedSubtitlesV2
  title: String!
}

enum PodcastSourceTypeV2 {
  none
  podigee
  vimeo
}

interface PodcastSourceV2 {
  sourceType: PodcastSourceTypeV2!
}

type PodcastWithTimestamp implements ElementV2 {
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  podcastFile: File
  timestampsWithImage: [TimestampWithImage!]!
  title: String!
}

type PodcastWithTimestampLearnElement implements LearnElement {
  duration: Int!
  elementType: ElementTypeV2!
  end: Int!
  """The ID of an object"""
  id: ID!
  podcastFile: File!
  start: Int!
  timestampsWithImage: [TimestampWithImage!]!
  title: String!
}

type PodigeePodcastSourceV2 implements PodcastSourceV2 {
  lengthInSeconds: Int!
  podigeeUrl: String!
  sourceType: PodcastSourceTypeV2!
}

type PositiveRestartIfFailedContentConfigResult implements RestartIfFailedContentConfigResult {
  canBeRestarted: Boolean!
  configType: RestartIfFailedContentConfigType!
}

interface PotentialAnalysisAnswerOption {
  answerOptionId: Int!
}

"""A connection to a list of items."""
type PotentialAnalysisConnection {
  """A list of edges."""
  edges: [PotentialAnalysisEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PotentialAnalysisEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: AVGSPotentialAnalysis_PotentialAnalysis!
}

input PotentialAnalysisFreeTextAnswerOptionInput {
  answerOptionId: Int!
  isFreeText: Boolean!
  text: String!
}

type PotentialAnalysisFreetextAnswerOption implements PotentialAnalysisAnswerOption {
  answerOptionId: Int!
  isFreeText: Boolean!
  text: String!
}

interface PotentialAnalysisGivenAnswer {
  kind: PotentialAnalysisGivenAnswerKind!
}

enum PotentialAnalysisGivenAnswerKind {
  SelectedWithFreetext
  Text
  selected
}

type PotentialAnalysisMultipleChoiceFreetextQuestion implements PotentialAnalysisQuestion {
  answerOptions: [PotentialAnalysisFreetextAnswerOption!]!
  givenAnswers: [PotentialAnalysisSelectedWithFreetextGivenAnswer!]!
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
  questionText: String!
}

type PotentialAnalysisMultipleChoiceQuestion implements PotentialAnalysisQuestion {
  answerOptions: [PotentialAnalysisSelectAnswerOption!]!
  givenAnswers: [PotentialAnalysisSelectedGivenAnswer!]!
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
  questionText: String!
}

type PotentialAnalysisMutations {
  acknowledgePotentialAnalysisMaxReward(input: AcknowledgePotentialAnalysisMaxRewardInput!): AcknowledgePotentialAnalysisMaxRewardPayload
  createPotentialAnalysisClickout(input: CreatePotentialAnalysisClickoutInput!): CreatePotentialAnalysisClickoutPayload
}

interface PotentialAnalysisQuestion {
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
}

enum PotentialAnalysisQuestionDataKind {
  MULTIPLE_CHOICE
  MULTIPLE_CHOICE_FREETEXT
  SCALE
  SINGLE_CHOICE
  SINGLE_CHOICE_FREETEXT
  TEXT
}

input PotentialAnalysisRegistrationDataInput {
  language: String!
  ptt: Int!
  pttchk: String!
  rvw: Int!
  rvwchk: String!
}

type PotentialAnalysisResult {
  categoryResults: [CategoryResult!]!
  isLongAnalysis: Boolean!
  name: String!
  pdf: File
}

type PotentialAnalysisScaleQuestion implements PotentialAnalysisQuestion {
  answerOptions: [PotentialAnalysisSelectAnswerOption!]!
  givenAnswer: PotentialAnalysisSelectedGivenAnswer
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
  questionText: String!
}

type PotentialAnalysisSelectAnswerOption implements PotentialAnalysisAnswerOption {
  answerOptionId: Int!
  text: String!
}

input PotentialAnalysisSelectAnswerOptionInput {
  answerOptionId: Int!
  text: String!
}

type PotentialAnalysisSelectedGivenAnswer implements PotentialAnalysisGivenAnswer {
  answerOptionId: Int!
  kind: PotentialAnalysisGivenAnswerKind!
}

input PotentialAnalysisSelectedGivenAnswerInput {
  answerOptionId: Int!
}

type PotentialAnalysisSelectedWithFreetextGivenAnswer implements PotentialAnalysisGivenAnswer {
  answerOptionId: Int!
  freeText: String
  kind: PotentialAnalysisGivenAnswerKind!
}

input PotentialAnalysisSelectedWithFreetextGivenAnswerInput {
  answerOptionId: Int!
  text: String
}

type PotentialAnalysisSingleChoiceFreetextQuestion implements PotentialAnalysisQuestion {
  answerOptions: [PotentialAnalysisFreetextAnswerOption!]!
  givenAnswer: PotentialAnalysisSelectedWithFreetextGivenAnswer
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
  questionText: String!
}

type PotentialAnalysisSingleChoiceQuestion implements PotentialAnalysisQuestion {
  answerOptions: [PotentialAnalysisSelectAnswerOption!]!
  givenAnswer: PotentialAnalysisSelectedGivenAnswer
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
  questionText: String!
}

type PotentialAnalysisTextGivenAnswer implements PotentialAnalysisGivenAnswer {
  kind: PotentialAnalysisGivenAnswerKind!
  text: String!
}

input PotentialAnalysisTextGivenAnswerInput {
  text: String!
}

type PotentialAnalysisTextQuestion implements PotentialAnalysisQuestion {
  givenAnswer: PotentialAnalysisTextGivenAnswer
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
  questionText: String!
}

"""Data partaining to the current user"""
type PotentialAnalysisViewerSchema {
  MyPotentialAnalysisResult: PotentialAnalysisResult
}

type Price {
  grossPrice: BigDecimal!
  netPrice: BigDecimal!
  taxRatePercentage: BigDecimal!
}

input PriceInput {
  grossPrice: BigDecimal = 0
  netPrice: BigDecimal = 0
  taxRatePercentage: BigDecimal = 19
}

type PrivateBaseData implements baseData {
  city: String
  countryCode: CountryCode
  firstName: String
  houseNumber: String
  lastName: String
  phoneNumber: String
  postalCode: String
  salutation: SalutationType
  street: String
  title: String
}

input PrivateBaseDataInput {
  city: String!
  countryCode: CountryCode!
  firstName: String!
  houseNumber: String!
  lastName: String!
  phoneNumber: String
  postalCode: String!
  salutation: SalutationType!
  street: String!
  title: String
}

type PrivateBillingDetails implements BillingDetails {
  city: String!
  country: String!
  customerType: CustomerType!
  dateOfBirth: ZonedDateTIme!
  firstName: String!
  houseNumber: String!
  invoiceAddress: InvoiceAddress
  invoiceEmail: String!
  lastName: String!
  phoneNumber: String!
  postalCode: String!
  salutation: SalutationType!
  street: String!
  title: String
}

type Product implements Node {
  data: ProductData!
  extensions: [ProductExtension!]!
  """The ID of an object"""
  id: ID!
  isHidden: Boolean!
  isTaxFree: Boolean!
  netPrice: BigDecimal!
  title: String!
}

interface ProductData {
  kind: ProductKind!
}

interface ProductExtension {
  kind: ProductExtensionKind!
}

enum ProductExtensionKind {
  Academies
}

enum ProductKind {
  AccountGroup
  License
  Placement
}

type ProductSelectionCondition implements LimitedCartDiscountCondition {
  amount: Int!
  """The ID of an object"""
  id: ID!
  kind: LimitedCartDiscountConditionKindEnum!
  product: Product
  productId: ID!
}

interface ProductSelectionConfig {
  kind: ProductSelectionConfigKindEnum!
}

enum ProductSelectionConfigKindEnum {
  Percentage
}

"""A connection to a list of items."""
type ProductsConnection {
  """A list of edges."""
  edges: [ProductsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ProductsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Product!
}

type ProfileData {
  avatar: File
  basicPersonal: ProfileDataBasicPersonal!
  certificateAnswer: Int
  certificateFileIds: [File!]!
  coachingStrongPointsTopics: [String!]!
  description: String
  digitalAffinity1: Boolean
  digitalAffinity2: Boolean
  educationFreeText: String
  educationMoreThan150h: Boolean
  experience: ProfileDataExperience!
  jobTitles: [String!]
  languages: [String!]!
  methods: [String!]!
  personalPhilosophyCoachingStyle: String
  personalPhilosophyVisionMission: String
  quote: String
  referencesCoachingExperienceIds: [File!]!
  referencesPublications: String
  socials: ProfileDataSocials
  studies: String
}

type ProfileDataBasicPersonal {
  email: String
  firstName: String
  lastName: String
  phoneNumber: String
  salutation: String
  title: String
}

input ProfileDataBasicPersonalInput {
  email: String
  firstName: String
  lastName: String
  phoneNumber: String
  salutation: String
  title: String
}

type ProfileDataExperience {
  branches: [String!]!
  branchesSteps: [String!]!
  coachingFileIds: [File!]!
  coachingHours: Int
}

input ProfileDataExperienceInput {
  branches: [String!]!
  branchesSteps: [String!]!
  coachingFileIds: [ID!]!
  coachingHours: Int
}

input ProfileDataInput {
  avatarId: ID
  basicPersonal: ProfileDataBasicPersonalInput!
  certificateAnswer: Int
  certificateFileIds: [ID!]!
  coachingStrongPointsTopics: [String!]!
  description: String
  digitalAffinity1: Boolean
  digitalAffinity2: Boolean
  educationFreeText: String
  educationMoreThan150h: Boolean
  experience: ProfileDataExperienceInput!
  jobTitles: [String!]
  languages: [String!]!
  methods: [String!]!
  personalPhilosophyCoachingStyle: String
  personalPhilosophyVisionMission: String
  quote: String
  referencesCoachingExperienceIds: [ID!]!
  referencesPublications: String
  socials: ProfileDataSocialsInput
  studies: String
}

type ProfileDataSocials {
  facebook: String
  linkedIn: String
  others: [String!]
  twitter: String
  website: String
}

input ProfileDataSocialsInput {
  facebook: String
  linkedIn: String
  others: [String!]
  twitter: String
  website: String
}

input PublishTriggerInput {
  clientMutationId: String
  triggerId: ID!
}

type PublishTriggerPayload {
  clientMutationId: String
  trigger: TriggerAction_Trigger!
}

type PublishedConstellationRootExtensionExtension implements PublishedRootExtensionExtension {
  contractPartner: ContractPartner
  doNotUse: String!
  isMicroLearning: Boolean!
  licenseAvailability: LicenseAvailability!
}

type PublishedCourseLearnable implements PublishedLearnable {
  id: ID!
  kind: LearnableKind!
  root: LearnOpportunityV2
}

type PublishedGroupCoachingLearnable implements PublishedLearnable {
  groupCoaching: CoachingOffer
  id: ID!
  kind: LearnableKind!
}

interface PublishedLearnable {
  id: ID!
  kind: LearnableKind!
}

"""A connection to a list of items."""
type PublishedLearnablesConnection {
  """A list of edges."""
  edges: [PublishedLearnablesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PublishedLearnablesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: PublishedLearnable!
}

type PublishedMicroLearningLearnable implements PublishedLearnable {
  id: ID!
  kind: LearnableKind!
  root: LearnOpportunityV2
}

type PublishedOneToOneCoachingLearnable implements PublishedLearnable {
  id: ID!
  kind: LearnableKind!
  oneToOneCoaching: CoachingOffer
}

interface PublishedRootExtensionExtension {
  doNotUse: String!
}

type PublishedRootExtensionImpl implements LearnOpportunityRootExtension {
  cartClickout: CartClickout
  diploma: String
  doNotUse: String!
  extension: PublishedRootExtensionExtension!
  ihkState: IHKCertificateOrderStateKind!
  learnGoals: String
  product: Product
  receivedGamificationPoints: Int!
  reducedData: ReducedData
  systemTags: [SystemTag!]!
  tags: [AcademiesTag!]!
  trailer: StreamFile
  unlockInfo: UnlockInfo!
}

type PublishingMessageV2 {
  additionalMessage: String
  message: String!
  timestamp: ZonedDateTIme!
}

enum PublishingStatus {
  acknowledged
  failed
  inprogress
  succeeded
}

type PublishingUpdatedEventV2 {
  name: String!
  publishing: PublishingV2!
  tree: Tree!
}

type PublishingV2 implements Node {
  canBeAcknowledged: Boolean!
  finishedAt: ZonedDateTIme
  """The ID of an object"""
  id: ID!
  initiatedAt: ZonedDateTIme!
  messages: [PublishingMessageV2!]!
  status: PublishingStatus!
}

"""Data only accessible by the admin"""
type PublishingV2AdminMutationSchema {
  acknowledgePublishingV2(input: AcknowledgePublishingV2Input!): AcknowledgePublishingV2Payload
  startPublishingV2(input: StartPublishingV2Input!): StartPublishingV2Payload
}

"""Data only accessible by the admin"""
type PublishingV2AdminSchema {
  ActivePublishing(rootId: ID!): PublishingV2
}

type PurchaseUpdate implements HistoryEventInterface {
  kind: HistoryEventType!
}

type Purchaser {
  accountId: ID!
  userId: ID!
}

type Query {
  AcademiesTag: AcademiesTagQueries!
  AccountBaseData: AccountBaseDataQueries!
  AccountMemberManagement: AccountMemberManagementQueries!
  """Data only accessible by the admin"""
  Admin: AdminQueryType!
  Auth: AuthQueries!
  AvgsPotentialAnalysis: AvgsPotentialAnalysisQueries!
  Coaching: CoachingQueries!
  CustomerJourney: CustomerJourneyQueries!
  FeatureToggle: FeatureToggleQueries!
  Learn: LearnQueries!
  Learnable: LearnableQueries!
  LicenseGrouping: LicenseGroupingQueries!
  Management: ManagementQueries!
  Ping: PingQueries!
  Placement: PlacementQueries!
  """Data partaining to the current user"""
  Viewer: ViewerQueryType!
  Vocab: VocabQueries!
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node
  """Fetches objects given their IDs"""
  nodes(
    """The IDs of objects"""
    ids: [ID!]!
  ): [Node]!
}

input RearrangeElementsV2Input {
  clientMutationId: String
  eLearningContentNodeId: ID!
  newElementIds: [ID!]!
}

type RearrangeElementsV2Payload {
  clientMutationId: String
  eLearningContentNode: TreeNode!
}

type ReducedData {
  containsVideo: Boolean!
  isIHK: Boolean!
  numAttachments: Int!
  numBranches: Int!
  numContents: Int!
  receivableGamificationPoints: Int!
  videoDurationInSec: Long!
}

type Refusal {
  code: String!
  discountCodeId: ID!
  refusalReason: RefusalReason!
  title: String!
}

enum RefusalReason {
  DuplicatedSystemCode
  DuplicatedUserCode
  Expired
  OverLimit
  OverUserLimit
  WrongAccount
  WrongProducts
}

input RegisterForNotificationInput {
  clientMutationId: String
  service: NotificationServiceType!
  token: String!
}

type RegisterForNotificationPayload {
  clientMutationId: String
}

input RegisterParticipationAdminInput {
  availabilityId: ID!
  clientMutationId: String
  participantId: ID!
  participationStatus: ParticipationStatus!
}

type RegisterParticipationAdminPayload {
  availability: Availability!
  clientMutationId: String
}

input RegisterParticipationInput {
  availabilityId: ID!
  clientMutationId: String
  participantId: ID!
  participationStatus: ParticipationStatus!
}

type RegisterParticipationPayload {
  availability: Availability!
  clientMutationId: String
}

input RegisterUserInput {
  adsOptIn: Boolean!
  branch: Branch
  clientMutationId: String
  email: String!
  firstName: String!
  lastName: String!
  position: String
  potentialAnalysisRegistrationData: PotentialAnalysisRegistrationDataInput
  rawPassword: String!
  teamSize: TeamSize
}

type RegisterUserPayload {
  accountId: ID!
  clientMutationId: String
  firstLogin: Boolean!
  userId: ID!
}

type ReleasedFileV2 {
  file: File
}

type ReleasedSubtitlesV2 {
  subtitles: SubtitlesV2
  vimeoId: String!
}

input RemoveActionFromActionResultToNextActionsAndDeleteItInput {
  actionId: ID!
  clientMutationId: String
}

type RemoveActionFromActionResultToNextActionsAndDeleteItPayload {
  clientMutationId: String
  deletedActionId: ID!
}

input RemoveAttachmentInput {
  attachmentId: ID!
  clientMutationId: String
  nodeId: ID!
}

type RemoveAttachmentPayload {
  clientMutationId: String
  node: TreeNode!
}

input RemoveColumnFromMatrixElementInput {
  clientMutationId: String
  idx: Int!
  matrixElementId: ID!
}

type RemoveColumnFromMatrixElementPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
}

input RemoveNodeFromTreeInput {
  clientMutationId: String
  nodeId: ID!
}

type RemoveNodeFromTreePayload {
  clientMutationId: String
  tree: Tree!
}

input RemoveOrderItemInput {
  clientMutationId: String
  orderElementId: ID!
  orderItemId: ID!
}

type RemoveOrderItemPayload {
  clientMutationId: String
  orderElement: OrderElement!
}

input RemoveParticipantAdminInput {
  availabilityId: ID!
  clientMutationId: String
  participantId: ID!
}

type RemoveParticipantAdminPayload {
  availability: Availability!
  clientMutationId: String
}

input RemoveParticipantFromBookingAsCoachInput {
  availabilityId: ID!
  clientMutationId: String
  participantId: ID!
}

type RemoveParticipantFromBookingAsCoachPayload {
  availability: Availability!
  clientMutationId: String
}

input RemoveParticipantFromMyBookingInput {
  availabilityId: ID!
  clientMutationId: String
  participantId: ID!
}

type RemoveParticipantFromMyBookingPayload {
  availability: Availability!
  clientMutationId: String
}

input RemoveRestartIfFailedContentConfigInput {
  clientMutationId: String
  configId: ID!
  contentNodeId: ID!
}

type RemoveRestartIfFailedContentConfigPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input RemoveRewardTreeConfigInput {
  clientMutationId: String
  configId: ID!
  rootNodeId: ID!
}

type RemoveRewardTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input RemoveRowFromMatrixElementInput {
  clientMutationId: String
  idx: Int!
  matrixElementId: ID!
}

type RemoveRowFromMatrixElementPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
}

input RemoveStartContentConfigInput {
  clientMutationId: String
  configId: ID!
  contentNodeId: ID!
}

type RemoveStartContentConfigPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input RemoveStartTreeConfigInput {
  clientMutationId: String
  configId: ID!
  rootNodeId: ID!
}

type RemoveStartTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input RemoveUserFromAccountInput {
  accountId: ID!
  clientMutationId: String
  userId: ID!
}

type RemoveUserFromAccountPayload {
  clientMutationId: String
  removedUserId: ID!
}

input RemoveUsersFromAccountInput {
  clientMutationId: String
  userIds: [ID!]!
}

type RemoveUsersFromAccountPayload {
  clientMutationId: String
  removedIds: [ID!]!
}

input RemoveUsersFromUserInAccountGroupInput {
  clientMutationId: String
  groupId: ID!
  userIds: [ID!]!
}

type RemoveUsersFromUserInAccountGroupPayload {
  clientMutationId: String
  removedIds: [ID!]!
}

input RemoveVisibilityCoachingConfigInput {
  clientMutationId: String
  coachingOfferId: ID!
  configId: ID!
}

type RemoveVisibilityCoachingConfigPayload {
  clientMutationId: String
  coachingOffer: CoachingOffer!
}

input RemoveVisibilityTreeConfigInput {
  clientMutationId: String
  configId: ID!
  rootNodeId: ID!
}

type RemoveVisibilityTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input RemoveWrongAnswerFromMatrixElementCellInput {
  clientMutationId: String
  matrixCellId: ID!
  matrixElementId: ID!
  wrongAnswerId: ID!
}

type RemoveWrongAnswerFromMatrixElementCellPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
}

"""Data only accessible by the admin"""
type ReportsAdminSchema {
  Reports(after: String, before: String, first: Int, last: Int, referenceNumber: String): DSAReportConnection!
}

type ReportsMutations {
  createReport(input: CreateReportInput!): CreateReportPayload
}

"""Data partaining to the current user"""
type ReportsViewerSchema {
  SystemEmail: String!
}

input ResendActivationInput {
  clientMutationId: String
  email: String!
}

type ResendActivationPayload {
  clientMutationId: String
}

input ResetAllStagingDataInput {
  clientMutationId: String
}

type ResetAllStagingDataPayload {
  clientMutationId: String
}

input ResetPasswordAndActivateInput {
  clientMutationId: String
  newPassword: String!
  token: String!
}

type ResetPasswordAndActivatePayload {
  clientMutationId: String
}

input ResetStagingBillingInput {
  clientMutationId: String
}

type ResetStagingBillingPayload {
  clientMutationId: String
}

input ResetStagingUsersInput {
  clientMutationId: String
}

type ResetStagingUsersPayload {
  clientMutationId: String
}

input RestartContentNodeAfterFailedInput {
  clientMutationId: String
  contentNodeId: ID!
}

type RestartContentNodeAfterFailedPayload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

input RestartContentNodeAfterPassedInput {
  clientMutationId: String
  contentNodeId: ID!
}

type RestartContentNodeAfterPassedPayload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

interface RestartIfFailedContentConfig {
  configType: RestartIfFailedContentConfigType!
  """The ID of an object"""
  id: ID!
}

interface RestartIfFailedContentConfigResult {
  canBeRestarted: Boolean!
  configType: RestartIfFailedContentConfigType!
}

enum RestartIfFailedContentConfigType {
  RestartIfFailedContent_BlockPermanently
  RestartIfFailedContent_BlockTemporarily
  RestartIfFailedContent_CanNot
}

interface RestartIfPassedContentConfig {
  configType: RestartIfPassedContentConfigType!
  """The ID of an object"""
  id: ID!
}

enum RestartIfPassedContentConfigType {
  RestartIfPassedContent_Can
  RestartIfPassedContent_CanNot
}

interface Reward {
  """The ID of an object"""
  id: ID!
  kind: RewardKind!
  superId: ID!
}

interface RewardContentConfig {
  configType: RewardContentConfigType!
  """The ID of an object"""
  id: ID!
}

enum RewardContentConfigType {
  RewardContent_Do
}

enum RewardKind {
  CrmTreeHeadUpdater
  ExternalLicense
  GamificationPoints
  IHKCertificate
  ParticipationCertificate
  WordPackage
  WordProficiencies
}

interface RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

enum RewardResultKind {
  CrmTreeHeadUpdater_ErrorOccurred
  CrmTreeHeadUpdater_HeadUpdated
  CrmTreeHeadUpdater_NotPassed
  ExternalLicense_ErrorOccurred
  ExternalLicense_IssuedToUser
  ExternalLicense_NotPassed
  GamificationPoints_AlreadyReceivedPoints
  GamificationPoints_ErrorOccurred
  GamificationPoints_NoPointsReceived
  GamificationPoints_NotPassedIHKTestFlow
  GamificationPoints_PointsReceived
  IHKCertificate_ErrorOccurred
  IHKCertificate_ReadyToOrder
  ParticipationCertificate_ParticipationCertificate
  WordPackage_ErrorOccurred
  WordPackage_NothingNewToUnlock
  WordPackage_PackageUnlocked
  WordProficiencies_ErrorOccurred
  WordProficiencies_ProficienciesChanged
}

interface RewardTreeConfig {
  configType: RewardTreeConfigType!
  """The ID of an object"""
  id: ID!
}

enum RewardTreeConfigType {
  RewardTree_DoNot
}

type RootCost {
  percentageShare: Int!
  price: BigDecimal!
  supplier: String!
}

input RootCostInput {
  percentageShare: Int!
  price: BigDecimal!
  supplier: String!
}

interface RootExtension {
  doNotUse: String!
}

interface RootExtensionExtension {
  doNotUse: String!
}

type RootExtensionImpl implements RootExtension {
  cost: RootCost
  diploma: String
  doNotUse: String!
  extension: RootExtensionExtension!
  learnGoalsOpt: String
  product: Product
  tags: [AcademiesTag!]!
  trailerOpt: Trailer
}

type RootNodesWithTreeStateType {
  rootNode: LearnOpportunityV2
  treeState: TreeState
}

type RootStructureDefinition implements StructureDefinition {
  coordinates: CoordinatesV2!
  definitionType: StructureType!
  extension: RootExtension!
  firstReleasedAt: ZonedDateTIme
  icon: File
  rewardConfigs: [RewardTreeConfig!]!
  searchWords: String
  showAnswerConfig: ShowAnswerTreeConfig!
  startAtConfig: StartAtTreeConfig!
  startConfigs: [StartTreeConfig!]!
  tags: [Tag!]!
  title: String!
  visibilityConfigs: [VisibilityTreeConfig!]!
}

enum SalutationType {
  Divers
  Mr
  Mrs
  Unknown
}

type ScheduleData {
  blockoutDates: [BlockoutDate!]!
  daysAndTimes: [AvailabilityScheduleDayAndTimes!]!
  overrideDaysAndTimesForCalendarWeek: [DayAndTimesForCalendarWeek!]!
}

input ScheduleDataInput {
  blockoutDates: [BlockoutDateInput!]!
  daysAndTimes: [DayAndTimesInput!]!
  overrideDaysAndTimesForCalendarWeek: [DayAndTimesForCalendarWeekInput!]!
}

"""result of searching discount code usages."""
type SearchDiscountCodeUsagesResult {
  csv: String!
  sumGrossPriceWithDiscounts: BigDecimal!
  sumGrossPriceWithoutDiscounts: BigDecimal!
  usages(after: String, before: String, first: Int, last: Int): DiscountCodeUsagesConnection!
}

interface SelectedPaymentMethod {
  paymentMethodId: PaymentMethodType!
  selectedPaymentMethodType: SelectedPaymentMethodType!
}

enum SelectedPaymentMethodType {
  EmployerInvoice
  MonthlyPayment
  OneTimePayment
}

type SelectedProduct {
  amount: Int!
  product: Product
}

input SelectedProductInput {
  additionalInformation: String
  amount: Int!
  productId: ID!
}

type Selection {
  createdByUser: User
  selectedDiscountCodes: [String!]!
  selectedProducts: [SelectedProduct!]!
}

input SendAskCompanyIfContractWasConcludedInput {
  clientMutationId: String
  contactPersonAccountId: ID!
  contactPersonUserId: ID!
  jobListingTitle: String!
  linkId: String!
}

type SendAskCompanyIfContractWasConcludedPayload {
  clientMutationId: String
}

input SendCompanyIsInterestedInUserProfileInput {
  clientMutationId: String
  deadlineMatching: ZonedDateTIme!
  jobListingInterestedYes: Boolean!
  jobListingTitle: String!
  linkId: String!
  userId: ID!
}

type SendCompanyIsInterestedInUserProfilePayload {
  clientMutationId: String
}

input SendEmailInput {
  clientMutationId: String
  email: String!
  personalizedEmailTemplateId: ID!
}

type SendEmailPayload {
  clientMutationId: String
}

input SendInformAboutAcceptedMatchingInput {
  businessAccountId: ID!
  clientMutationId: String
  jobListingTitle: String!
  userId: ID!
}

type SendInformAboutAcceptedMatchingPayload {
  clientMutationId: String
}

input SendInformAboutAvailableDossierInput {
  businessAccountId: ID!
  businessUserId: ID!
  clientMutationId: String
  jobListingId: String!
  jobListingTitle: String!
}

type SendInformAboutAvailableDossierPayload {
  clientMutationId: String
}

input SendInformAboutClosedProfileAfterMatchingInput {
  clientMutationId: String
  linkId: String!
  nextMatchingRoundDate: ZonedDateTIme!
  userId: ID!
}

type SendInformAboutClosedProfileAfterMatchingPayload {
  clientMutationId: String
}

input SendMatchingResultsAvailableToBusinessInput {
  businessAccountId: ID!
  businessUserId: ID!
  clientMutationId: String
  deadlineMatching: ZonedDateTIme!
  linkId: String!
}

type SendMatchingResultsAvailableToBusinessPayload {
  clientMutationId: String
}

input SendMatchingResultsAvailableToUserInput {
  clientMutationId: String
  deadlineMatching: ZonedDateTIme!
  linkId: String!
  userId: ID!
}

type SendMatchingResultsAvailableToUserPayload {
  clientMutationId: String
}

input SendRemindCompanyToPayFeeInput {
  clientMutationId: String
  jobListingTitle: String!
  managerAccountId: ID!
  managerUserId: ID!
}

type SendRemindCompanyToPayFeePayload {
  clientMutationId: String
}

input SendReminderForInviteToSecondInterviewInput {
  clientMutationId: String
  contactPersonAccountId: ID!
  contactPersonUserId: ID!
  deadlineMatching: ZonedDateTIme!
  jobListingTitle: String!
  linkId: String!
}

type SendReminderForInviteToSecondInterviewPayload {
  clientMutationId: String
}

input SendReminderForSecondInterviewToUserInput {
  clientMutationId: String
  deadlineMatching: ZonedDateTIme!
  linkId: String!
  userId: ID!
}

type SendReminderForSecondInterviewToUserPayload {
  clientMutationId: String
}

input SendSummaryForFirstInterviewToContactPersonInput {
  accountId: ID!
  clientMutationId: String
  interviewDate: ZonedDateTIme!
  jobListingTitle: String!
  linkId: String!
  userId: ID!
}

type SendSummaryForFirstInterviewToContactPersonPayload {
  clientMutationId: String
}

input SendSummaryForFirstInterviewToUserInput {
  clientMutationId: String
  interviewDate: ZonedDateTIme!
  linkId: String!
  userId: ID!
}

type SendSummaryForFirstInterviewToUserPayload {
  clientMutationId: String
}

input SendSummaryForSecondInterviewToContactPersonInput {
  clientMutationId: String
  contactPersonAccountId: ID!
  contactPersonUserId: ID!
  interviewDate: ZonedDateTIme!
  jobListingTitle: String!
  linkId: String!
}

type SendSummaryForSecondInterviewToContactPersonPayload {
  clientMutationId: String
}

input SendSummaryForSecondInterviewToUserInput {
  businessAccountId: ID!
  clientMutationId: String
  interviewDate: ZonedDateTIme!
  linkId: String!
  userId: ID!
}

type SendSummaryForSecondInterviewToUserPayload {
  clientMutationId: String
}

input SendUserIsInterestedForJobListingInput {
  clientMutationId: String
  contactPersonAccountId: ID!
  contactPersonUserId: ID!
  deadlineMatching: ZonedDateTIme!
  jobListingTitle: String!
  linkId: String!
  userId: ID!
}

type SendUserIsInterestedForJobListingPayload {
  clientMutationId: String
}

type SepaData implements PaymentProviderData {
  dataType: PaymentProviderDataType!
  iban: String!
  mandateInformation: MandateInformation!
  paymentMethod: PaymentMethodType!
}

type SessionLineItem {
  coach: User
  coachingOffer: CoachingOffer
  remuneration: Price!
  sessionFrom: ZonedDateTIme!
  sessionTo: ZonedDateTIme!
}

input SetAccountBaseDataCountryInput {
  clientMutationId: String
  countryCode: CountryCode!
}

type SetAccountBaseDataCountryPayload {
  baseData: baseData!
  clientMutationId: String
}

input SetAccountGroupsInput {
  clientMutationId: String
  groupIds: [ID!]!
  id: ID!
}

type SetAccountGroupsPayload {
  account: Account!
  clientMutationId: String
}

input SetAccountNameInput {
  clientMutationId: String
  id: ID!
  name: String!
}

type SetAccountNamePayload {
  account: Account!
  clientMutationId: String
}

input SetAccountNameUserInput {
  clientMutationId: String
  id: ID!
  name: String!
}

type SetAccountNameUserPayload {
  account: Account!
  clientMutationId: String
}

input SetActionNameInput {
  actionId: ID!
  clientMutationId: String
  name: String!
}

type SetActionNamePayload {
  action: TriggerAction_Action!
  clientMutationId: String
}

input SetAlwaysPassContentConfigInput {
  clientMutationId: String
  contentNodeId: ID!
}

type SetAlwaysPassContentConfigPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input SetAlwaysRestartContinueContentConfigInput {
  clientMutationId: String
  contentNodeId: ID!
}

type SetAlwaysRestartContinueContentConfigPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input SetAnswerInMultipleChoiceFreeTextQuestionInput {
  answerOptions: [PotentialAnalysisFreeTextAnswerOptionInput!]!
  clientMutationId: String
  givenAnswer: [PotentialAnalysisSelectedWithFreetextGivenAnswerInput!]!
  learnPotentialAnalysisId: ID!
  questionId: ID!
  questionText: String!
}

type SetAnswerInMultipleChoiceFreeTextQuestionPayload {
  clientMutationId: String
  isFinished: Boolean!
  question: PotentialAnalysisMultipleChoiceFreetextQuestion
}

input SetAnswerInMultipleChoiceQuestionInput {
  answerOptions: [PotentialAnalysisSelectAnswerOptionInput!]!
  clientMutationId: String
  givenAnswer: [PotentialAnalysisSelectedGivenAnswerInput!]!
  learnPotentialAnalysisId: ID!
  questionId: ID!
  questionText: String!
}

type SetAnswerInMultipleChoiceQuestionPayload {
  clientMutationId: String
  isFinished: Boolean!
  question: PotentialAnalysisMultipleChoiceQuestion!
}

input SetAnswerInScaleQuestionInput {
  answerOptions: [PotentialAnalysisSelectAnswerOptionInput!]!
  clientMutationId: String
  givenAnswer: PotentialAnalysisSelectedGivenAnswerInput!
  learnPotentialAnalysisId: ID!
  questionId: ID!
  questionText: String!
}

type SetAnswerInScaleQuestionPayload {
  clientMutationId: String
  isFinished: Boolean!
  question: PotentialAnalysisScaleQuestion!
}

input SetAnswerInSingleChoiceFreeTextQuestionInput {
  answerOptions: [PotentialAnalysisFreeTextAnswerOptionInput!]!
  clientMutationId: String
  givenAnswer: PotentialAnalysisSelectedWithFreetextGivenAnswerInput!
  learnPotentialAnalysisId: ID!
  questionId: ID!
  questionText: String!
}

type SetAnswerInSingleChoiceFreeTextQuestionPayload {
  clientMutationId: String
  isFinished: Boolean!
  question: PotentialAnalysisSingleChoiceFreetextQuestion
}

input SetAnswerInSingleChoiceQuestionInput {
  answerOptions: [PotentialAnalysisSelectAnswerOptionInput!]!
  clientMutationId: String
  givenAnswer: PotentialAnalysisSelectedGivenAnswerInput!
  learnPotentialAnalysisId: ID!
  questionId: ID!
  questionText: String!
}

type SetAnswerInSingleChoiceQuestionPayload {
  clientMutationId: String
  isFinished: Boolean!
  question: PotentialAnalysisSingleChoiceQuestion!
}

input SetAnswerInTextQuestionInput {
  clientMutationId: String
  givenAnswer: PotentialAnalysisTextGivenAnswerInput!
  learnPotentialAnalysisId: ID!
  questionId: ID!
  questionText: String!
}

type SetAnswerInTextQuestionPayload {
  clientMutationId: String
  isFinished: Boolean!
  question: PotentialAnalysisTextQuestion
}

input SetCanNotRestartIfPassedContentConfigInput {
  clientMutationId: String
  contentNodeId: ID!
}

type SetCanNotRestartIfPassedContentConfigPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input SetCanRestartIfPassedContentConfigInput {
  clientMutationId: String
  contentNodeId: ID!
}

type SetCanRestartIfPassedContentConfigPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input SetConstellationRootExtensionExtensionInput {
  clientMutationId: String
  isMicroLearning: Boolean!
  rootId: ID!
}

type SetConstellationRootExtensionExtensionPayload {
  clientMutationId: String
  root: TreeNode!
}

input SetContractPartnerInConstellationRootExtensionExtensionInput {
  clientMutationId: String
  contractPartner: ID
  rootId: ID!
}

type SetContractPartnerInConstellationRootExtensionExtensionPayload {
  clientMutationId: String
  root: TreeNode!
}

input SetCorrectAnswerInMatrixElementCellInput {
  clientMutationId: String
  matrixCellId: ID!
  matrixElementId: ID!
  newCorrectAnswerContent: String!
}

type SetCorrectAnswerInMatrixElementCellPayload {
  clientMutationId: String
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
}

input SetDirectFeedbackFlowELearningContentConfigInput {
  clientMutationId: String
  contentId: ID!
  minNumTriesTillShowAnswer: Int!
}

type SetDirectFeedbackFlowELearningContentConfigPayload {
  clientMutationId: String
  content: TreeNode!
}

input SetDoNotShowAnswerTreeConfigInput {
  clientMutationId: String
  rootNodeId: ID!
}

type SetDoNotShowAnswerTreeConfigPayload {
  clientMutationId: String
  rootNode: TreeNode!
}

input SetDoRewardContentConfigInput {
  clientMutationId: String
  contentNodeId: ID!
}

type SetDoRewardContentConfigPayload {
  clientMutationId: String
  contentNode: TreeNode!
}

input SetFieldValueKindAndIdMapInActionResultToNextActionInput {
  actionId: ID!
  clientMutationId: String
  fieldValueKindAndIdMap: [TriggerAction_FieldValueKindAndIdMapEntryInput!]!
}

type SetFieldValueKindAndIdMapInActionResultToNextActionPayload {
  action: TriggerAction_Action!
  clientMutationId: String
}

input SetFinishContentSubmissionTriggerInContentInput {
  clientMutationId: String
  contentId: ID!
}

type SetFinishContentSubmissionTriggerInContentPayload {
  clientMutationId: String
  content: TreeNode!
}

input SetGlobalDiscountCodeIdInput {
  clientMutationId: String
  discountCodeId: ID
}

type SetGlobalDiscountCodeIdPayload {
  clientMutationId: String
  settings: Settings!
}

input SetIHKFlowPassContentConfigInput {
  clientMutationId: String
  contentNodeId: ID!
}

type SetIHKFlowPassContentConfigPayload {
  clientMutationId: String
  content: TreeNode!
}

input SetMatrixElementColumnTitleInput {
  clientMutationId: String
  idx: Int!
  matrixElementId: ID!
  newTitle: String!
}

type SetMatrixElementColumnTitlePayload {
  clientMutationId: String
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
}

input SetMatrixElementRowTitleInput {
  clientMutationId: String
  idx: Int!
  matrixElementId: ID!
  newTitle: String!
}

type SetMatrixElementRowTitlePayload {
  clientMutationId: String
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
}

input SetRootExtensionImplInput {
  clientMutationId: String
  cost: RootCostInput
  diploma: String
  learnGoals: String
  licenseProductId: ID
  rootId: ID!
  tagIds: [ID!]!
  trailerVimeoId: String
  videoSourceId: ID
}

type SetRootExtensionImplPayload {
  clientMutationId: String
  root: TreeNode!
}

input SetSimplyContinueFlowELearningContentConfigInput {
  clientMutationId: String
  contentId: ID!
}

type SetSimplyContinueFlowELearningContentConfigPayload {
  clientMutationId: String
  content: TreeNode!
}

input SetTreeStateHeadInput {
  clientMutationId: String
  newHeadContentId: ID!
  rootId: ID!
  userId: ID!
}

type SetTreeStateHeadPayload {
  clientMutationId: String
  treeState: TreeState!
}

input SetTrendOrderInput {
  clientMutationId: String
  trendIdsWithPositions: [TrendIdWithPosition!]!
}

type SetTrendOrderPayload {
  clientMutationId: String
}

input SetTriggerNameInput {
  clientMutationId: String
  name: String!
  triggerId: ID!
}

type SetTriggerNamePayload {
  clientMutationId: String
  trigger: TriggerAction_Trigger!
}

input SetUserInAccountGroupsInput {
  accountId: ID!
  clientMutationId: String
  groupIds: [ID!]!
  userId: ID!
}

type SetUserInAccountGroupsPayload {
  clientMutationId: String
  userInAccount: UserInAccountEdge!
}

input SetVimeoVideoSourceAsDefaultInput {
  clientMutationId: String
  id: ID!
}

type SetVimeoVideoSourceAsDefaultPayload {
  clientMutationId: String
  edge: Vimeo_VimeoVideoSourceEdge!
}

type Settings {
  globalDiscountCode: DiscountCode
  """The ID of an object"""
  id: ID!
}

"""Data only accessible by the admin"""
type SettingsAdminMutationSchema {
  setGlobalDiscountCodeId(input: SetGlobalDiscountCodeIdInput!): SetGlobalDiscountCodeIdPayload
}

"""Data only accessible by the admin"""
type SettingsAdminSchema {
  Settings(after: String, before: String, first: Int, last: Int): Settings!
}

interface ShowAnswerElementState {
  element: LearnElement!
  kind: ElementStateKind!
}

interface ShowAnswerTreeConfig {
  configType: ShowAnswerTreeConfigType!
  """The ID of an object"""
  id: ID!
}

enum ShowAnswerTreeConfigType {
  ShowAnswerTree_DoNot
}

input ShowElementAnswerElementInput {
  clientMutationId: String
  contentSubmissionId: ID!
  inputElementId: ID!
}

type ShowElementAnswerElementPayload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

type SimplyContinueFlowELearningContentConfig implements FlowELearningContentConfig {
  configType: FlowELearningContentConfigType!
  """The ID of an object"""
  id: ID!
}

type SingleUserAssignmentRule implements AssignmentRule & Node {
  accountRef: ID!
  """The ID of an object"""
  id: ID!
  licenseGroupingId: ID!
  licensesUsedByUser: Int!
  maxLicenseAmount: Int!
  userId: ID!
}

"""A connection to a list of items."""
type SortedLearnablesConnection {
  """A list of edges."""
  edges: [SortedLearnablesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type SortedLearnablesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: LearnableWithLastUpdated!
}

"""Data only accessible by the admin"""
type StagingAdminMutationSchema {
  cleanUpUserInputRelatedToStaging(input: CleanUpUserInputRelatedToStagingInput!): CleanUpUserInputRelatedToStagingPayload
  createCoachStatementsFromUnbilled(input: CreateCoachStatementsFromUnbilledInput!): CreateCoachStatementsFromUnbilledPayload
  resetAllStagingData(input: ResetAllStagingDataInput!): ResetAllStagingDataPayload
  resetStagingBilling(input: ResetStagingBillingInput!): ResetStagingBillingPayload
  resetStagingUsers(input: ResetStagingUsersInput!): ResetStagingUsersPayload
}

interface StartAtTreeConfig {
  configType: StartAtTreeConfigType!
  """The ID of an object"""
  id: ID!
}

enum StartAtTreeConfigType {
  StartAtTree_FirstContentNode
}

interface StartContentConfig {
  configType: StartContentConfigType!
  """The ID of an object"""
  id: ID!
}

enum StartContentConfigType {
  StartContent_CanAfterStartingTree
  StartContent_CanIfInTreeFlow
  StartContent_CanIfUnlocked
  StartContent_CanNot
}

input StartContentNodeInput {
  clientMutationId: String
  contentNodeId: ID!
}

type StartContentNodePayload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

input StartPublishingV2Input {
  clientMutationId: String
  rootNodeId: ID!
}

type StartPublishingV2Payload {
  clientMutationId: String
  tree: Tree!
}

input StartStandaloneVocabTrainingInput {
  clientMutationId: String
  numWords: Int!
  words: [WordInPackageInput!]!
}

type StartStandaloneVocabTrainingPayload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

interface StartTreeConfig {
  configType: StartTreeConfigType!
  """The ID of an object"""
  id: ID!
}

enum StartTreeConfigType {
  StartTree_CanNot
}

input StartTreeInput {
  clientMutationId: String
  nodeId: ID!
  startAtContentNodeId: ID
}

type StartTreePayload {
  clientMutationId: String
  learnOpportunity: LearnOpportunityV2!
}

type StartedTreeStateDefinition implements TreeStateDefinition {
  headContentNode: TreeNode
  status: TreeStateStatus!
}

type StreamFile {
  """The ID of an object"""
  id: ID!
  thumbnail: String
  url: String
}

type StripeData implements PaymentProviderData {
  dataType: PaymentProviderDataType!
  paymentIntentId: String!
  paymentIntentSecret: String!
  paymentMethod: PaymentMethodType!
}

type StripeEmptyInvoiceData implements InvoiceData {
  kind: InvoiceDataKind!
}

type StripeSepaData implements PaymentProviderData {
  dataType: PaymentProviderDataType!
  mandateInformation: MandateInformation!
  paymentIntentId: String!
  paymentIntentSecret: String!
  paymentMethod: PaymentMethodType!
}

interface StructureDefinition {
  coordinates: CoordinatesV2!
  definitionType: StructureType!
  title: String!
}

enum StructureType {
  child
  root
}

input SubmitClozeTextElementV2Input {
  checkedAnswers: [ID!]!
  clientMutationId: String
  clozeTextElementId: ID!
  contentSubmissionId: ID!
}

type SubmitClozeTextElementV2Payload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

input SubmitDisplayElementInput {
  clientMutationId: String
  contentSubmissionId: ID!
  displayElementId: ID!
}

type SubmitDisplayElementPayload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

input SubmitMarkMistakesElementV2Input {
  checkedMistakeIndices: [Int!]!
  clientMutationId: String
  contentSubmissionId: ID!
  markMistakesElementId: ID!
}

type SubmitMarkMistakesElementV2Payload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

input SubmitMatrixElementV2Input {
  checkedIndices: [SubmitMatrixIndexCellInput!]!
  clientMutationId: String
  contentSubmissionId: ID!
  matrixElementId: ID!
}

type SubmitMatrixElementV2Payload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

input SubmitMatrixIndexCellInput {
  index: Int!
  xIdx: Int!
  yIdx: Int!
}

input SubmitMultipleChoiceElementV2Input {
  checkedAnswerIndices: [Int!]!
  clientMutationId: String
  contentSubmissionId: ID!
  multipleChoiceElementId: ID!
}

type SubmitMultipleChoiceElementV2Payload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

input SubmitOrderElementInput {
  clientMutationId: String
  contentSubmissionId: ID!
  order: [ID!]!
  orderElementId: ID!
}

type SubmitOrderElementPayload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

input SubmitUploadAsyncElementInput {
  clientMutationId: String
  contentSubmissionId: ID!
  fileId: ID!
  uploadAsyncElementId: ID!
}

type SubmitUploadAsyncElementPayload {
  clientMutationId: String
  contentSubmission: ContentSubmission!
}

type Subscription {
  subscribeToPublishingUpdatesV2: PublishingUpdatedEventV2!
}

enum SubtitleLanguage {
  de
  en
}

type SubtitleV2 {
  endTime: Long!
  startTime: Long!
  text: String!
}

type SubtitlesForLanguage {
  language: SubtitleLanguage!
  subtitles: [VideoSubtitle!]!
  transcriptFileId: File
}

type SubtitlesV2 {
  subtitles: [SubtitleV2!]!
}

input SwitchAccountInput {
  clientMutationId: String
  refreshToken: String!
  targetAccount: ID!
}

type SwitchAccountPayload {
  clientMutationId: String
  jwtTokens: JwtLoginInformation!
}

input SyncHubspotContactsWithUsersInput {
  clientMutationId: String
}

type SyncHubspotContactsWithUsersPayload {
  clientMutationId: String
}

type SystemDiscountType implements DiscountType {
  kind: DiscountTypeKind!
}

enum SystemTag {
  finished
  fullAccess
  new
  testAccess
}

type Tag implements Node {
  colorHex: String!
  """The ID of an object"""
  id: ID!
  name: String!
}

"""Data only accessible by the admin"""
type TagAdminMutationSchema {
  createTag(input: CreateTagInput!): CreateTagPayload
  deleteTag(input: DeleteTagInput!): DeleteTagPayload
  updateTag(input: UpdateTagInput!): UpdateTagPayload
}

"""Data only accessible by the admin"""
type TagAdminSchema {
  Tags(after: String, before: String, filterByName: String, first: Int, last: Int): TagsConnection!
}

input TagDataInput {
  isClickable: Boolean!
  isTopic: Boolean!
  name: String!
}

input TagInput {
  clientMutationId: String
  colorHex: String!
  name: String!
}

"""A connection to a list of items."""
type TagsConnection {
  """A list of edges."""
  edges: [TagsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TagsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Tag!
}

enum TargetSystem {
  android
  ios
}

type TaxData {
  taxIdentificationNumber: String!
  taxNumber: String!
}

input TaxDataInput {
  taxIdentificationNumber: String!
  taxNumber: String!
}

type TaxTotals {
  discountTotal: BigDecimal!
  grossPrice: BigDecimal!
  hasTaxFreeProducts: Boolean!
  netPrice: BigDecimal!
  taxTotal: BigDecimal!
}

enum TeamSize {
  fiftyToHundred
  oneToTen
  overHundred
  tenToTwentyFive
  twentyFiveToFifty
}

type TextElementV2 implements ElementV2 {
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  text: String!
  title: String!
}

type TextLearnElement implements LearnElement {
  elementType: ElementTypeV2!
  """The ID of an object"""
  id: ID!
  text: String!
  title: String!
}

type TextPart implements ClozeTextPart {
  """The ID of an object"""
  id: ID!
  kind: ClozeTextPartKind!
  text: String!
}

type TimestampWithImage {
  end: Int!
  imageFile: File
  start: Int!
}

input TimestampWithImageInput {
  end: Int!
  imageFileId: ID
  start: Int!
}

type Trailer {
  videoSourceId: ID!
  vimeoId: String
}

input TransformBusinessAccountToAVGSAccountInput {
  accountId: ID!
  clientMutationId: String
}

type TransformBusinessAccountToAVGSAccountPayload {
  clientMutationId: String
}

input TransformBusinessAccountToAZAVAccountInput {
  accountId: ID!
  clientMutationId: String
}

type TransformBusinessAccountToAZAVAccountPayload {
  clientMutationId: String
}

input TransformPrivateAccountToAVGSAccountInput {
  accountId: ID!
  businessBaseData: BusinessBaseDataInput!
  clientMutationId: String
}

type TransformPrivateAccountToAVGSAccountPayload {
  clientMutationId: String
}

input TransformPrivateAccountToAZAVAccountInput {
  accountId: ID!
  businessBaseData: BusinessBaseDataInput!
  clientMutationId: String
}

type TransformPrivateAccountToAZAVAccountPayload {
  clientMutationId: String
}

type Tree {
  """The ID of an object"""
  id: ID!
  nodes: [TreeNode!]!
  rootNode: TreeNode
}

"""Data only accessible by the admin"""
type TreeAdminMutationSchema {
  AddOnlyIfTreeStateVisibilityTreeConfig(input: AddOnlyIfTreeStateVisibilityTreeConfigInput!): AddOnlyIfTreeStateVisibilityTreeConfigPayload
  EditDefaultFileAttachment(input: EditDefaultFileAttachmentInput!): EditDefaultFileAttachmentPayload
  addAfterDateTimeVisibilityTreeConfig(input: AddAfterDateTimeVisibilityTreeConfigInput!): AddAfterDateTimeVisibilityTreeConfigPayload
  addBlockPermanentlyRestartIfFailedContentConfig(input: AddBlockPermanentlyRestartIfFailedContentConfigInput!): AddBlockPermanentlyRestartIfFailedContentConfigPayload
  addBlockTemporarilyRestartIfFailedContentConfig(input: AddBlockTemporarilyRestartIfFailedContentConfigInput!): AddBlockTemporarilyRestartIfFailedContentConfigPayload
  addCanAfterStartingTreeStartContentConfig(input: AddCanAfterStartingTreeStartContentConfigInput!): AddCanAfterStartingTreeStartContentConfigPayload
  addCanIfUnlockedStartContentConfig(input: AddCanIfUnlockedStartContentConfigInput!): AddCanIfUnlockedStartContentConfigPayload
  addCanNotRestartIfFailedContentConfig(input: AddCanNotRestartIfFailedContentConfigInput!): AddCanNotRestartIfFailedContentConfigPayload
  addCrmTreeHeadUpdaterReward(input: AddCrmTreeHeadUpdaterRewardInput!): AddCrmTreeHeadUpdaterRewardPayload
  addDefaultFileAttachment(input: AddDefaultFileAttachmentInput!): AddDefaultFileAttachmentPayload
  addDoNotRewardTreeConfig(input: AddDoNotRewardTreeConfigInput!): AddDoNotRewardTreeConfigPayload
  addEducationalParticipationCertificateReward(input: AddEducationalParticipationCertificateRewardInput!): AddEducationalParticipationCertificateRewardPayload
  addExternalLicenseReward(input: AddExternalLicenseRewardInput!): AddExternalLicenseRewardPayload
  addHideVisibilityTreeConfig(input: AddHideVisibilityTreeConfigInput!): AddHideVisibilityTreeConfigPayload
  addIHKCertificateReward(input: AddIHKCertificateRewardInput!): AddIHKCertificateRewardPayload
  addNotAfterDateTimeVisibilityTreeConfig(input: AddNotAfterDateTimeVisibilityTreeConfigInput!): AddNotAfterDateTimeVisibilityTreeConfigPayload
  addOnlyAZAVAccountVisibilityTreeConfig(input: AddOnlyAZAVAccountVisibilityTreeConfigInput!): AddOnlyAZAVAccountVisibilityTreeConfigPayload
  addOnlyAdminsVisibilityTreeConfig(input: AddOnlyAdminsVisibilityTreeConfigInput!): AddOnlyAdminsVisibilityTreeConfigPayload
  addOnlyBusinessAccountVisibilityTreeConfig(input: AddOnlyBusinessAccountVisibilityTreeConfigInput!): AddOnlyBusinessAccountVisibilityTreeConfigPayload
  addOnlyEditorsVisibilityTreeConfig(input: AddOnlyEditorsVisibilityTreeConfigInput!): AddOnlyEditorsVisibilityTreeConfigPayload
  addWordPackageReward(input: AddWordPackageRewardInput!): AddWordPackageRewardPayload
  addWordProficienciesReward(input: AddWordProficienciesRewardInput!): AddWordProficienciesRewardPayload
  cloneTree(input: CloneTreeInput!): CloneTreePayload
  constellationCreateBranchRoot(input: ConstellationCreateBranchRootInput!): ConstellationCreateBranchRootPayload
  createBranchChild(input: CreateBranchChildInput!): CreateBranchChildPayload
  createBranchRoot(input: CreateBranchRootInput!): CreateBranchRootPayload
  createContentChild(input: CreateContentChildInput!): CreateContentChildPayload
  createContentRoot(input: CreateContentRootNodeInput!): CreateContentRootNodePayload
  deleteCourseOrMicroLearningLearnable(input: DeleteCourseOrMicroLearningLearnableInput!): DeleteCourseOrMicroLearningLearnablePayload
  deleteReward(input: DeleteRewardInput!): DeleteRewardPayload
  editAfterDateTimeVisibilityTreeConfig(input: EditAfterDateTimeVisibilityTreeConfigInput!): EditAfterDateTimeVisibilityTreeConfigPayload
  editBlockPermanentlyRestartIfFailedContentConfig(input: EditBlockPermanentlyRestartIfFailedContentConfigInput!): EditBlockPermanentlyRestartIfFailedContentConfigPayload
  editBlockTemporarilyRestartIfFailedContentConfig(input: EditBlockTemporarilyRestartIfFailedContentConfigInput!): EditBlockTemporarilyRestartIfFailedContentConfigPayload
  editDirectFeedbackFlowELearningContentConfig(input: EditDirectFeedbackFlowELearningContentConfigInput!): EditDirectFeedbackFlowELearningContentConfigPayload
  editEducationalParticipationCertificateReward(input: EditEducationalParticipationCertificateRewardInput!): EditEducationalParticipationCertificateRewardPayload
  editExternalLicenseReward(input: EditExternalLicenseRewardInput!): EditExternalLicenseRewardPayload
  editNodeCore(input: EditNodeCoreInput!): EditNodeCorePayload
  editNotAfterDateTimeVisibilityTreeConfig(input: EditNotAfterDateTimeVisibilityTreeConfigInput!): EditNotAfterDateTimeVisibilityTreeConfigPayload
  editRootNodePart(input: EditRootNodePartInput!): EditRootNodePartPayload
  editWordPackageReward(input: EditWordPackageRewardInput!): EditWordPackageRewardPayload
  moveChildNode(input: MoveChildNodeInput!): MoveChildNodePayload
  removeAttachment(input: RemoveAttachmentInput!): RemoveAttachmentPayload
  removeNodeFromTree(input: RemoveNodeFromTreeInput!): RemoveNodeFromTreePayload
  removeRestartIfFailedContentConfig(input: RemoveRestartIfFailedContentConfigInput!): RemoveRestartIfFailedContentConfigPayload
  removeRewardTreeConfig(input: RemoveRewardTreeConfigInput!): RemoveRewardTreeConfigPayload
  removeStartContentConfig(input: RemoveStartContentConfigInput!): RemoveStartContentConfigPayload
  removeStartTreeConfig(input: RemoveStartTreeConfigInput!): RemoveStartTreeConfigPayload
  removeVisibilityTreeConfig(input: RemoveVisibilityTreeConfigInput!): RemoveVisibilityTreeConfigPayload
  setAlwaysPassContentConfig(input: SetAlwaysPassContentConfigInput!): SetAlwaysPassContentConfigPayload
  setAlwaysRestartContinueContentConfig(input: SetAlwaysRestartContinueContentConfigInput!): SetAlwaysRestartContinueContentConfigPayload
  setCanNotRestartIfPassedContentConfig(input: SetCanNotRestartIfPassedContentConfigInput!): SetCanNotRestartIfPassedContentConfigPayload
  setCanRestartIfPassedContentConfig(input: SetCanRestartIfPassedContentConfigInput!): SetCanRestartIfPassedContentConfigPayload
  setConstellationRootExtensionExtension(input: SetConstellationRootExtensionExtensionInput!): SetConstellationRootExtensionExtensionPayload
  setContractPartnerInConstellationRootExtensionExtension(input: SetContractPartnerInConstellationRootExtensionExtensionInput!): SetContractPartnerInConstellationRootExtensionExtensionPayload
  setDirectFeedbackFlowELearningContentConfig(input: SetDirectFeedbackFlowELearningContentConfigInput!): SetDirectFeedbackFlowELearningContentConfigPayload
  setDoNotShowAnswerTreeConfig(input: SetDoNotShowAnswerTreeConfigInput!): SetDoNotShowAnswerTreeConfigPayload
  setDoRewardContentConfig(input: SetDoRewardContentConfigInput!): SetDoRewardContentConfigPayload
  setFinishContentSubmissionTriggerInContent(input: SetFinishContentSubmissionTriggerInContentInput!): SetFinishContentSubmissionTriggerInContentPayload
  setIHKFlowPassContentConfig(input: SetIHKFlowPassContentConfigInput!): SetIHKFlowPassContentConfigPayload
  setRootExtensionImpl(input: SetRootExtensionImplInput!): SetRootExtensionImplPayload
  setSimplyContinueFlowELearningContentConfig(input: SetSimplyContinueFlowELearningContentConfigInput!): SetSimplyContinueFlowELearningContentConfigPayload
}

"""Data only accessible by the admin"""
type TreeAdminSchema {
  GetContentNodes(after: String, before: String, first: Int, last: Int): TreeNodesConnection!
  GetRootNodes(after: String, before: String, filterByAttachmentId: ID, filterByCanBeRewardedFrom: ZonedDateTIme, filterByCanBeRewardedTo: ZonedDateTIme, filterByIsReleased: Boolean, filterByIsVisibleFrom: ZonedDateTIme, filterByIsVisibleTo: ZonedDateTIme, filterByReleasedAtFrom: ZonedDateTIme, filterByShowAnswersFrom: ZonedDateTIme, filterByShowAnswersTo: ZonedDateTIme, filterByTagIds: [ID!], filterByTitleOrDescriptionOrShortDescription: String, first: Int, last: Int): TreeNodesConnection!
  Tree(rootId: ID!): Tree!
}

type TreeLicenseDefinitionData implements LicenseDefinitionData {
  kind: LicenseDefinitionDataKind!
  name: String!
  rootInfo: LicenseDefinitionRootInfo
}

input TreeLicenseDefinitionDataInput {
  name: String!
  rootId: ID!
}

type TreeNode implements Node {
  attachments: [AttachmentV2!]!
  description: String
  hasBeenPublishedOnce: Boolean!
  """The ID of an object"""
  id: ID!
  image: File
  imageId: ID
  instructors: [Instructor!]!
  parentId: ID
  rootId: ID!
  shortDescription: String
  structureDefinition: StructureDefinition!
  typeDefinition: TypeDefinition!
  versioning: Versioning!
}

"""A connection to a list of items."""
type TreeNodesConnection {
  """A list of edges."""
  edges: [TreeNodesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TreeNodesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: TreeNode!
}

type TreeState implements Node {
  definition: TreeStateDefinition!
  extension: TreeStateExtension!
  """The ID of an object"""
  id: ID!
  progressPercentage: Int!
  rootNode: TreeNode!
  startedAt: ZonedDateTIme!
  user: User
}

interface TreeStateDefinition {
  status: TreeStateStatus!
}

interface TreeStateExtension {
  doNotUse: String!
}

enum TreeStateStatus {
  finished
  started
}

"""A connection to a list of items."""
type TreeStatesConnection {
  """A list of edges."""
  edges: [TreeStatesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TreeStatesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: TreeState!
}

type Trend implements Node {
  aboutOffersHeadingAndDescription: HeadingAndDescription!
  coachingHeadingAndDescription: HeadingAndDescription!
  coachingImage: File
  customerData: CustomerData!
  """The ID of an object"""
  id: ID!
  learnables: [PublishedLearnable!]!
  position: Int
  potentialAnalysisHeadingAndDescription: HeadingAndDescription!
  trendData: TrendData!
  trendMedia: TrendMedia!
}

"""Data only accessible by the admin"""
type TrendAdminMutationSchema {
  createTrend(input: CreateTrendInput!): CreateTrendPayload
  deleteTrend(input: DeleteTrendInput!): DeleteTrendPayload
  editTrend(input: EditTrendInput!): EditTrendPayload
  setTrendOrder(input: SetTrendOrderInput!): SetTrendOrderPayload
}

"""Data only accessible by the admin"""
type TrendAdminSchema {
  trend(after: String, before: String, first: Int, isVisible: Boolean, last: Int, text: String): TrendConnection!
}

"""A connection to a list of items."""
type TrendConnection {
  """A list of edges."""
  edges: [TrendEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type TrendData {
  advantages: [Advantage!]!
  description: String!
  icon: Icon!
  name: String!
  tags: [AcademiesTag!]!
  visible: Boolean!
}

input TrendDataInput {
  advantages: [AdvantageInput!]!
  description: String!
  icon: Icon!
  name: String!
  tagIds: [ID!]!
  visible: Boolean!
}

"""An edge in a connection."""
type TrendEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Trend!
}

input TrendIdWithPosition {
  position: Int!
  trendId: ID!
}

interface TrendMedia {
  file: File
  kind: TrendMediaKind!
}

input TrendMediaInput {
  image: ImageTrendMediaInput
  video: VideoTrendMediaInput
}

enum TrendMediaKind {
  image
  video
}

"""Data only accessible by the admin"""
type TriggerActionAdminMutationSchema {
  addGamificationPointsFinishContentSubmissionActionToActionResultToNextActions(input: AddGamificationPointsFinishContentSubmissionActionToActionResultToNextActionsInput!): AddGamificationPointsFinishContentSubmissionActionToActionResultToNextActionsPayload
  addGamificationPointsFinishContentSubmissionActionToTrigger(input: AddGamificationPointsFinishContentSubmissionActionToTriggerInput!): AddGamificationPointsFinishContentSubmissionActionToTriggerPayload
  addIHKCertificateFinishContentSubmissionActionToActionResultToNextActions(input: AddIHKCertificateFinishContentSubmissionActionToActionResultToNextActionsInput!): AddIHKCertificateFinishContentSubmissionActionToActionResultToNextActionsPayload
  addIHKCertificateFinishContentSubmissionActionToTrigger(input: AddIHKCertificateFinishContentSubmissionActionToTriggerInput!): AddIHKCertificateFinishContentSubmissionActionToTriggerPayload
  createActionResultToNextActions(input: CreateActionResultToNextActionsInput!): CreateActionResultToNextActionsPayload
  deleteAction(input: DeleteActionInput!): DeleteActionPayload
  deleteActionResultToNextActions(input: DeleteActionResultToNextActionsInput!): DeleteActionResultToNextActionsPayload
  publishTrigger(input: PublishTriggerInput!): PublishTriggerPayload
  removeActionFromActionResultToNextActionsAndDeleteIt(input: RemoveActionFromActionResultToNextActionsAndDeleteItInput!): RemoveActionFromActionResultToNextActionsAndDeleteItPayload
  removeActionFromTriggerAndDeleteIt(input: removeActionFromTriggerAndDeleteItInput!): removeActionFromTriggerAndDeleteItPayload
  setActionName(input: SetActionNameInput!): SetActionNamePayload
  setFieldValueKindAndIdMap(input: SetFieldValueKindAndIdMapInActionResultToNextActionInput!): SetFieldValueKindAndIdMapInActionResultToNextActionPayload
  setTriggerName(input: SetTriggerNameInput!): SetTriggerNamePayload
}

"""Data only accessible by the admin"""
type TriggerActionAdminSchema {
  ActionKinds(after: String, before: String, first: Int, last: Int): TriggerAction_ActionKindsConnection!
  AvailableFieldDefinitionsForActionIfParentActionResultToNextActions(after: String, before: String, first: Int, last: Int): TriggerAction_FieldDefinitionsConnection!
  AvailableFieldDefinitionsForActionIfParentTrigger(after: String, before: String, filterByFieldValueKind: TriggerAction_FieldValueKind, first: Int, last: Int, triggerId: ID!): TriggerAction_FieldDefinitionsConnection!
  FieldValueKindAndIdsForActionKind(actionKind: TriggerAction_ActionKind!, after: String, before: String, first: Int, last: Int): TriggerAction_FieldValueKindAndIdsConnection!
  Triggers(after: String, before: String, filterByName: String, first: Int, last: Int): TriggerAction_TriggersConnection!
}

type TriggerAction_Action implements Node {
  actionResultToNextActionsOpts(after: String, before: String, first: Int, last: Int): TriggerAction_ActionResultToNextActionsOptsConnection!
  data: TriggerAction_ActionData!
  fieldValueKindAndIdMap: [TriggerAction_FieldValueKindAndIdMapEntry!]!
  """The ID of an object"""
  id: ID!
  name: String!
}

interface TriggerAction_ActionData {
  kind: TriggerAction_ActionKind!
}

type TriggerAction_ActionInputFieldSource implements TriggerAction_FieldSource {
  actionKind: TriggerAction_ActionKind!
  kind: TriggerAction_FieldSourceKind!
}

enum TriggerAction_ActionKind {
  GamificationPointsFinishContentSubmission
  IHKCertificateFinishContentSubmission
}

"""A connection to a list of items."""
type TriggerAction_ActionKindsConnection {
  """A list of edges."""
  edges: [TriggerAction_ActionKindsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TriggerAction_ActionKindsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: TriggerAction_ActionKind!
}

enum TriggerAction_ActionResultKind {
  GamificationPointsFinishContentSubmission_AlreadyReceivedPoints
  GamificationPointsFinishContentSubmission_NoPointsReceived
  GamificationPointsFinishContentSubmission_NotPassedIHKTestFlow
  GamificationPointsFinishContentSubmission_PointsReceived
  IHKCertificateFinishContentSubmission_ReadyToOrder
}

type TriggerAction_ActionResultOutputFieldSource implements TriggerAction_FieldSource {
  action: TriggerAction_Action
  actionResultKind: TriggerAction_ActionResultKind!
  kind: TriggerAction_FieldSourceKind!
}

type TriggerAction_ActionResultToNextActions {
  actionResultKind: TriggerAction_ActionResultKind!
  """The ID of an object"""
  id: ID!
  nextActions(after: String, before: String, first: Int, last: Int): TriggerAction_ActionsConnection!
}

interface TriggerAction_ActionResultToNextActionsOpt {
  actionResultKind: TriggerAction_ActionResultKind!
  id: ID!
}

"""A connection to a list of items."""
type TriggerAction_ActionResultToNextActionsOptsConnection {
  """A list of edges."""
  edges: [TriggerAction_ActionResultToNextActionsOptsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TriggerAction_ActionResultToNextActionsOptsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: TriggerAction_ActionResultToNextActionsOpt!
}

"""A connection to a list of items."""
type TriggerAction_ActionsConnection {
  """A list of edges."""
  edges: [TriggerAction_ActionsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TriggerAction_ActionsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: TriggerAction_Action!
}

type TriggerAction_BuiltInOutputFieldSource implements TriggerAction_FieldSource {
  kind: TriggerAction_FieldSourceKind!
}

type TriggerAction_FieldDefinition {
  fieldIdWithinSource: ID!
  fieldValueKind: TriggerAction_FieldValueKind!
  source: TriggerAction_FieldSource!
}

"""A connection to a list of items."""
type TriggerAction_FieldDefinitionsConnection {
  """A list of edges."""
  edges: [TriggerAction_FieldDefinitionsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TriggerAction_FieldDefinitionsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: TriggerAction_FieldDefinition!
}

interface TriggerAction_FieldSource {
  kind: TriggerAction_FieldSourceKind!
}

enum TriggerAction_FieldSourceKind {
  ActionInput
  ActionResultOutput
  BuiltInOutput
  TriggerOutput
}

enum TriggerAction_FieldValueKind {
  AccountId
  Boolean
  DateTime
  GamificationPointsId
  IHKCertificateOrderId
  Int
  String
  TriggerKind
  UserId
}

type TriggerAction_FieldValueKindAndId {
  fieldValueKind: TriggerAction_FieldValueKind!
  """The ID of an object"""
  id: ID!
}

input TriggerAction_FieldValueKindAndIdInput {
  fieldId: ID!
  fieldValueKind: TriggerAction_FieldValueKindInput!
}

type TriggerAction_FieldValueKindAndIdMapEntry {
  fromOutput: TriggerAction_FieldValueKindAndId!
  toInput: TriggerAction_FieldValueKindAndId!
}

input TriggerAction_FieldValueKindAndIdMapEntryInput {
  fromOutput: TriggerAction_FieldValueKindAndIdInput!
  toInput: TriggerAction_FieldValueKindAndIdInput!
}

"""A connection to a list of items."""
type TriggerAction_FieldValueKindAndIdsConnection {
  """A list of edges."""
  edges: [TriggerAction_FieldValueKindAndIdsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TriggerAction_FieldValueKindAndIdsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: TriggerAction_FieldValueKindAndId!
}

enum TriggerAction_FieldValueKindInput {
  AccountId
  Boolean
  DateTime
  GamificationPointsId
  IHKCertificateOrderId
  Int
  String
  TriggerKind
  UserId
}

type TriggerAction_FinishContentSubmissionTriggerData implements TriggerAction_TriggerData {
  kind: TriggerAction_TriggerKind!
}

type TriggerAction_GamificationPointsFinishContentSubmissionActionData implements TriggerAction_ActionData {
  kind: TriggerAction_ActionKind!
}

type TriggerAction_IHKCertificateFinishContentSubmissionActionData implements TriggerAction_ActionData {
  kind: TriggerAction_ActionKind!
}

type TriggerAction_NoneActionResultToNextActions implements TriggerAction_ActionResultToNextActionsOpt {
  actionResultKind: TriggerAction_ActionResultKind!
  id: ID!
}

type TriggerAction_PublishedAction {
  actionResultToNextActionsOpts(after: String, before: String, first: Int, last: Int): TriggerAction_PublishedActionResultToNextActionsOptsConnection!
  data: TriggerAction_ActionData!
  """The ID of an object"""
  id: ID!
}

type TriggerAction_PublishedActionResultToNextActions {
  actionResultKind: TriggerAction_ActionResultKind!
  actions(after: String, before: String, first: Int, last: Int): TriggerAction_PublishedActionsConnection!
  """The ID of an object"""
  id: ID!
}

interface TriggerAction_PublishedActionResultToNextActionsOpt {
  id: ID!
}

"""A connection to a list of items."""
type TriggerAction_PublishedActionResultToNextActionsOptsConnection {
  """A list of edges."""
  edges: [TriggerAction_PublishedActionResultToNextActionsOptsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TriggerAction_PublishedActionResultToNextActionsOptsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: TriggerAction_PublishedActionResultToNextActionsOpt!
}

"""A connection to a list of items."""
type TriggerAction_PublishedActionsConnection {
  """A list of edges."""
  edges: [TriggerAction_PublishedActionsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TriggerAction_PublishedActionsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: TriggerAction_PublishedAction!
}

type TriggerAction_PublishedNoneActionResultToNextActions implements TriggerAction_PublishedActionResultToNextActionsOpt {
  actionResultKind: TriggerAction_ActionResultKind!
  id: ID!
}

type TriggerAction_PublishedSomeActionResultToNextActions implements TriggerAction_PublishedActionResultToNextActionsOpt {
  actionResultToNextAction: TriggerAction_PublishedActionResultToNextActions
  id: ID!
}

type TriggerAction_PublishedTrigger {
  actions(after: String, before: String, first: Int, last: Int): TriggerAction_PublishedActionsConnection!
  data: TriggerAction_TriggerData!
  """The ID of an object"""
  id: ID!
}

type TriggerAction_SomeActionResultToNextActions implements TriggerAction_ActionResultToNextActionsOpt {
  actionResultKind: TriggerAction_ActionResultKind!
  actionResultToNextAction: TriggerAction_ActionResultToNextActions
  id: ID!
}

type TriggerAction_Trigger implements Node {
  actions(after: String, before: String, first: Int, last: Int): TriggerAction_ActionsConnection!
  data: TriggerAction_TriggerData!
  doUnpublishedChangesExist: Boolean!
  """The ID of an object"""
  id: ID!
  name: String!
  publishedTrigger: TriggerAction_PublishedTrigger
}

interface TriggerAction_TriggerData {
  kind: TriggerAction_TriggerKind!
}

enum TriggerAction_TriggerKind {
  FinishContentSubmission
}

type TriggerAction_TriggerOutputFieldSource implements TriggerAction_FieldSource {
  kind: TriggerAction_FieldSourceKind!
  triggerKind: TriggerAction_TriggerKind!
}

"""A connection to a list of items."""
type TriggerAction_TriggersConnection {
  """A list of edges."""
  edges: [TriggerAction_TriggersEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TriggerAction_TriggersEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: TriggerAction_Trigger!
}

input TriggerResendActivationInput {
  clientMutationId: String
  userId: ID!
}

type TriggerResendActivationPayload {
  clientMutationId: String
}

input TriggerResetPasswordInput {
  clientMutationId: String
  userId: ID!
}

type TriggerResetPasswordPayload {
  clientMutationId: String
}

interface TypeDefinition {
  definitionType: TypeDefinitionType!
}

enum TypeDefinitionType {
  branch
  content
}

interface UnlockInfo {
  kind: UnlockInfoKind!
}

type UnlockInfoDemo implements UnlockInfo {
  firstContentCoordinatesIndexPath: [Int!]!
  firstContentId: ID!
  kind: UnlockInfoKind!
}

type UnlockInfoFullAccess implements UnlockInfo {
  kind: UnlockInfoKind!
}

enum UnlockInfoKind {
  Demo
  ErrorOccurred
  FullAccess
  WallNotFound
}

type UnlockInfoWallNotFound implements UnlockInfo {
  kind: UnlockInfoKind!
}

type UnpublishedCourseLearnable implements UnpublishedLearnable {
  id: ID!
  kind: LearnableKind!
  root: TreeNode
}

type UnpublishedGroupCoachingLearnable implements UnpublishedLearnable {
  groupCoaching: CoachingOffer
  id: ID!
  kind: LearnableKind!
}

interface UnpublishedLearnable {
  id: ID!
  kind: LearnableKind!
}

"""A connection to a list of items."""
type UnpublishedLearnablesConnection {
  """A list of edges."""
  edges: [UnpublishedLearnablesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type UnpublishedLearnablesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: UnpublishedLearnable!
}

type UnpublishedMicroLearningLearnable implements UnpublishedLearnable {
  id: ID!
  kind: LearnableKind!
  root: TreeNode
}

type UnpublishedOneToOneCoachingLearnable implements UnpublishedLearnable {
  id: ID!
  kind: LearnableKind!
  oneToOneCoaching: CoachingOffer
}

type UntouchedAndPreviouslyIncorrectElementState implements ElementState {
  element: LearnElement!
  kind: ElementStateKind!
}

type UntouchedElementState implements ElementState {
  element: LearnElement!
  kind: ElementStateKind!
}

input UpdateBusinessBillingDetailsAndInitiateCheckoutInput {
  city: String!
  clientMutationId: String
  company: String!
  companyDetails: String
  companyType: CompanyTypeInput!
  houseNumber: String!
  invoiceEmail: String
  orderId: ID!
  phoneNumber: String!
  postalCode: String!
  street: String!
  taxIdentificationNumber: String!
}

type UpdateBusinessBillingDetailsAndInitiateCheckoutPayload {
  clientMutationId: String
  clientSecret: String!
  order: Order!
}

input UpdateBusinessBillingDetailsInput {
  city: String!
  clientMutationId: String
  company: String!
  companyDetails: String
  companyType: CompanyTypeInput!
  country: String!
  houseNumber: String!
  invoiceEmail: String
  orderId: ID!
  phoneNumber: String!
  postalCode: String!
  street: String!
  taxIdentificationNumber: String
}

type UpdateBusinessBillingDetailsPayload {
  clientMutationId: String
  order: Order!
}

input UpdateCartInput {
  cartSelection: CartSelectionInput!
  clientMutationId: String
  orderId: ID!
}

type UpdateCartPayload {
  clientMutationId: String
  order: Order!
}

input UpdateInstructorImplInput {
  clientMutationId: String
  data: InstructorImplInput!
  id: ID!
}

type UpdateInstructorImplPayload {
  clientMutationId: String
  data: InstructorImplsEdge!
}

input UpdatePersonalizedEmailTemplateInput {
  clientMutationId: String
  data: PersonalizedEmailTemplateInput!
  id: ID!
}

type UpdatePersonalizedEmailTemplatePayload {
  clientMutationId: String
  data: PersonalizedEmailTemplatesEdge!
}

input UpdatePersonalizedNotificationTemplateInput {
  clientMutationId: String
  data: PersonalizedNotificationTemplateInput!
  id: ID!
}

type UpdatePersonalizedNotificationTemplatePayload {
  clientMutationId: String
  data: PersonalizedNotificationTemplatesEdge!
}

input UpdatePrivateBillingDetailsAndInitiateCheckoutInput {
  city: String!
  clientMutationId: String
  dateOfBirth: ZonedDateTIme!
  firstName: String!
  houseNumber: String!
  lastName: String!
  orderId: ID!
  phoneNumber: String!
  postalCode: String!
  salutation: SalutationType!
  street: String!
  title: String
}

type UpdatePrivateBillingDetailsAndInitiateCheckoutPayload {
  clientMutationId: String
  clientSecret: String!
  order: Order!
}

input UpdatePrivateBillingDetailsInput {
  city: String!
  clientMutationId: String
  country: String!
  dateOfBirth: ZonedDateTIme!
  firstName: String!
  houseNumber: String!
  lastName: String!
  orderId: ID!
  phoneNumber: String!
  postalCode: String!
  salutation: SalutationType!
  street: String!
  title: String
}

type UpdatePrivateBillingDetailsPayload {
  clientMutationId: String
  order: Order!
}

input UpdateTagInput {
  clientMutationId: String
  data: TagInput!
  id: ID!
}

type UpdateTagPayload {
  clientMutationId: String
  data: TagsEdge!
}

input UpdateUsageLimited {
  maxAmountOfUsages: Int
  maxAmountOfUsagesPerAccount: Int
  onlyForAccountIds: [ID!]!
  onlyForProductIds: [ID!]!
}

type UploadAsyncElement implements AsyncElement {
  assignedEvaluator: User
  """The ID of an object"""
  id: ID!
  kind: AsyncElementKind!
  taskDescription: String
  title: String!
}

interface UploadAsyncElementTask {
  assignedEvaluator: User
  elementKind: AsyncElementKind!
  extension: AsyncElementTaskExtension!
  file: File
  id: ID!
  status: AsyncElementTaskStatus!
  submissionInfo: AsyncElementTaskSubmissionInfo!
}

type UploadAsyncLearnElement implements AsyncLearnElement {
  elementKind: AsyncElementKind!
  file: File
  """The ID of an object"""
  id: ID!
  taskDescription: String!
  title: String!
}

type UploadEvaluation {
  file: File
  text: String
}

type User implements Node {
  activated: Boolean!
  email: String!
  extension(userExtensionKind: UserExtensionKind!): UserExtension
  extensions: [UserExtension!]!
  groupAssociations: [UserGroupAssociation!]!
  """The ID of an object"""
  id: ID!
  isDeleted: Boolean!
  name: String!
  registeredAt: ZonedDateTIme!
}

"""A connection to a list of items."""
type UserConnection {
  """A list of edges."""
  edges: [UserEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type UserDiscountType implements DiscountType {
  kind: DiscountTypeKind!
}

"""An edge in a connection."""
type UserEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: User!
}

interface UserExtension {
  kind: UserExtensionKind!
}

enum UserExtensionKind {
  Academies
}

type UserGroupAssociation {
  account: Account
  group: UserInAccountGroup
}

type UserInAccount implements Node {
  groups: [UserInAccountGroup!]!
  """The ID of an object"""
  id: ID!
  user: User!
}

"""A connection to a list of items."""
type UserInAccountConnection {
  """A list of edges."""
  edges: [UserInAccountEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type UserInAccountEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: UserInAccount!
}

type UserInAccountGroup implements Node {
  """The ID of an object"""
  id: ID!
  isBuiltIn: Boolean!
  name: String!
  permissions: [Permission!]!
}

type UserInAccountGroupWrapper {
  group: UserInAccountGroup!
  """The ID of an object"""
  id: ID!
  memberCount: Long!
  newInvitations(after: String, before: String, first: Int, last: Int): AccountMemberConnection!
}

"""A connection to a list of items."""
type UserInAccountGroupWrapperConnection {
  """A list of edges."""
  edges: [UserInAccountGroupWrapperEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type UserInAccountGroupWrapperEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: UserInAccountGroupWrapper!
}

type UserInAccountGroupWrappersResult {
  count: Long!
  userInAccountGroupWrappers(after: String, before: String, first: Int, last: Int): UserInAccountGroupWrapperConnection!
}

"""A connection to a list of items."""
type UserInAccountGroupsConnection {
  """A list of edges."""
  edges: [UserInAccountGroupsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type UserInAccountGroupsEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: UserInAccountGroup!
}

type UserInAccountWrapper implements AccountMember {
  groups: [UserInAccountGroup!]!
  id: ID!
  isManager: Boolean!
  kind: AccountMemberKind!
  name: String!
  user: UserInAccount!
}

type Versioning {
  draftVersion: Int!
  releaseVersion: Int!
}

type VideoDataV2 {
  duration: Int!
  name: String!
  thumbnailUrl: String!
  videoId: String!
}

type VideoElement implements ElementV2 {
  elementType: ElementTypeV2!
  extension: ElementExtension!
  """The ID of an object"""
  id: ID!
  title: String!
  vimeoId: String!
  vimeoVideoSource: Vimeo_VimeoVideoSource
}

type VideoLearnElement implements LearnElement {
  durationInSec: Int!
  elementType: ElementTypeV2!
  """The ID of an object"""
  id: ID!
  streamFile: StreamFile
  subtitles: [SubtitlesForLanguage!]!
  thumbnailFile: File
  title: String!
  videoFile: File
}

type VideoSubtitle {
  endTimeInSec: Long!
  startTimeInSec: Long!
  text: String!
}

type VideoTrendMedia implements TrendMedia {
  file: File
  kind: TrendMediaKind!
}

input VideoTrendMediaInput {
  fileId: ID!
  trendMediaType: TrendMediaKind!
}

"""Data partaining to the current user"""
type ViewerMutationType {
  Auth: AuthViewerMutationSchema!
}

"""Data partaining to the current user"""
type ViewerQueryType {
  Auth: AuthViewerSchema!
  Billing: BillingViewerSchema!
  Coaching: CoachingViewerSchema!
  Learn: LearnViewerSchema!
  PotentialAnalysis: PotentialAnalysisViewerSchema!
  Reports: ReportsViewerSchema!
}

interface ViewerTreeState {
  kind: ViewerTreeStateKind!
}

enum ViewerTreeStateKind {
  CanBeStarted
  CanNotBeStarted
  IsFinished
  IsStarted
  NotVisible
}

type VimeoPodcastSourceV2 implements PodcastSourceV2 {
  sourceType: PodcastSourceTypeV2!
  videoSource: Vimeo_VimeoVideoSource
  vimeoId: String!
}

"""Data only accessible by the admin"""
type VimeoVideoSourceAdminMutationSchema {
  createVimeoVideoSource(input: CreateVimeoVideoSourceInput!): CreateVimeoVideoSourcePayload
  deleteVimeoVideoSource(input: DeleteVimeoVideoSourceInput!): DeleteVimeoVideoSourcePayload
  editVimeoVideoSource(input: EditVimeoVideoSourceInput!): EditVimeoVideoSourcePayload
  setVimeoVideoSourceAsDefault(input: SetVimeoVideoSourceAsDefaultInput!): SetVimeoVideoSourceAsDefaultPayload
}

"""Data only accessible by the admin"""
type VimeoVideoSourceAdminSchema {
  GetDefaultVimeoVideoSource: Vimeo_VimeoVideoSource
  VimeoVideoSources(after: String, before: String, first: Int, last: Int): Vimeo_VimeoVideoSourceConnection!
}

type Vimeo_VimeoVideoSource {
  accessToken: String!
  """The ID of an object"""
  id: ID!
  isDefault: Boolean!
  name: String!
}

"""A connection to a list of items."""
type Vimeo_VimeoVideoSourceConnection {
  """A list of edges."""
  edges: [Vimeo_VimeoVideoSourceEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type Vimeo_VimeoVideoSourceEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Vimeo_VimeoVideoSource!
}

interface VisibilityCoachingConfig {
  configType: VisibilityCoachingConfigType!
  """The ID of an object"""
  id: ID!
}

enum VisibilityCoachingConfigType {
  VisibilityCoaching_Hide
  VisibilityCoaching_OnlyAZAVAccount
  VisibilityCoaching_OnlyBusinessAccount
  VisibilityCoaching_OnlyWithLicense
}

interface VisibilityTreeConfig {
  configType: VisibilityTreeConfigType!
  """The ID of an object"""
  id: ID!
}

enum VisibilityTreeConfigType {
  VisibilityTree_AfterDateTime
  VisibilityTree_Hide
  VisibilityTree_NotAfterDateTime
  VisibilityTree_OnlyAZAVAccount
  VisibilityTree_OnlyAdmins
  VisibilityTree_OnlyBusinessAccount
  VisibilityTree_OnlyEditors
  VisibilityTree_OnlyIfTreeState
  VisibilityTree_OnlyPermissionsImpl
}

"""Data only accessible by the admin"""
type VocabAdminMutationSchema {
  addWordToPackage(input: AddWordToPackageInput!): AddWordToPackagePayload
  createWordPackage(input: CreateWordPackageInput!): CreateWordPackagePayload
  deleteWord(input: DeleteWordInput!): DeleteWordPayload
  deleteWordPackage(input: DeleteWordPackageInput!): DeleteWordPackagePayload
  editWord(input: EditWordInput!): EditWordPayload
  editWordPackage(input: EditWordPackageInput!): EditWordPackagePayload
}

"""Data only accessible by the admin"""
type VocabAdminSchema {
  WordPackages(after: String, alwaysInclude: [ID!], before: String, filterByName: String, first: Int, last: Int): WordPackageConnection!
}

type VocabMutations {
  addWordNote(input: AddWordNoteInput!): AddWordNotePayload
  startStandaloneVocabTraining(input: StartStandaloneVocabTrainingInput!): StartStandaloneVocabTrainingPayload
}

type VocabQueries {
  MyWordInventory: WordInventory
}

interface VocabTrainWordPackageSelection {
  kind: VocabTrainWordPackageSelectionKind!
  wordPackage: WordPackage
}

type VocabTrainWordPackageSelectionFullPackage implements VocabTrainWordPackageSelection {
  kind: VocabTrainWordPackageSelectionKind!
  wordPackage: WordPackage
}

enum VocabTrainWordPackageSelectionKind {
  FullPackage
  SpecificWords
}

type VocabTrainWordPackageSelectionSpecificWords implements VocabTrainWordPackageSelection {
  kind: VocabTrainWordPackageSelectionKind!
  wordIds: [ID!]!
  wordPackage: WordPackage
}

type Word {
  explanation: String!
  """The ID of an object"""
  id: ID!
  translation: String
  word: String!
}

input WordInPackageInput {
  packageId: ID!
  wordId: ID!
}

type WordInventory {
  """The ID of an object"""
  id: ID!
  notes: [WordNote!]!
  packages: [PackageUnlock!]!
  proficiencies: [WordProficiency!]!
}

type WordNote {
  note: String!
  wordId: ID!
}

type WordPackage implements Node {
  associatedWords: [Word!]!
  """The ID of an object"""
  id: ID!
  language: String!
  name: String!
}

"""A connection to a list of items."""
type WordPackageConnection {
  """A list of edges."""
  edges: [WordPackageEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

input WordPackageDataInput {
  language: String!
  name: String!
}

"""An edge in a connection."""
type WordPackageEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: WordPackage!
}

type WordPackageReward implements Reward {
  data: WordPackageRewardData!
  """The ID of an object"""
  id: ID!
  kind: RewardKind!
  superId: ID!
}

type WordPackageRewardData {
  wordPackage: WordPackage
}

input WordPackageRewardDataInput {
  wordPackageId: ID!
}

type WordPackage_ErrorOccurredRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type WordPackage_NothingNewToUnlockRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
  wordPackage: WordPackage
}

type WordPackage_PackageUnlockedRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
  wordPackage: WordPackage
}

type WordProficienciesReward implements Reward {
  """The ID of an object"""
  id: ID!
  kind: RewardKind!
  superId: ID!
}

type WordProficiencies_ErrorOccurredRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type WordProficiencies_ProficienciesChangedRewardResult implements RewardResult {
  kind: RewardResultKind!
  rewardId: ID!
  rewardKind: RewardKind!
}

type WordProficiency {
  proficiencyLevel: Int!
  wordId: ID!
}

scalar ZonedDateTIme

interface baseData {
  city: String
  countryCode: CountryCode
  houseNumber: String
  postalCode: String
  street: String
}

input deleteTagInput {
  clientMutationId: String
  id: ID!
}

type deleteTagPayload {
  clientMutationId: String
  deletedId: ID!
}

input editTagInput {
  clientMutationId: String
  data: TagDataInput!
  id: ID!
}

type editTagPayload {
  clientMutationId: String
  tag: AcademiesTag!
}

input removeActionFromTriggerAndDeleteItInput {
  actionId: ID!
  clientMutationId: String
}

type removeActionFromTriggerAndDeleteItPayload {
  clientMutationId: String
  deletedActionId: ID!
}